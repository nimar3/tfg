\documentclass[11pt,spanish,listoffigures,listoftables]{tfgetsinf}

\usepackage[utf8]{inputenc} 

% custom bulletpoint for tables
\usepackage{enumitem}
\newlist{tabitem}{itemize}{1}
\setlist[tabitem]{wide=0pt, nosep, leftmargin= * ,label=\textbullet,after=\vspace{-\baselineskip},before=\vspace{-0.6\baselineskip}}
%

% custom dedication
\newenvironment{dedication}
{%\clearpage           % we want a new page          %% I commented this
	\thispagestyle{empty}% no header and footer
	\itshape             % the text is in italics
}
{\par % end the paragraph
	\vspace{\stretch{3}} % space at bottom is three times that at the top
	\clearpage           % finish off the page
}

% link colors in table black
\hypersetup{%
	colorlinks = true,
	linkcolor  = black
}

% YAML definition  - START

\newcommand\YAMLcolonstyle{\color{red}\mdseries}
\newcommand\YAMLkeystyle{\color{black}\bfseries}
\newcommand\YAMLvaluestyle{\color{blue}\mdseries}

\makeatletter

% here is a macro expanding to the name of the language
% (handy if you decide to change it further down the road)
\newcommand\language@yaml{yaml}

\expandafter\expandafter\expandafter\lstdefinelanguage
\expandafter{\language@yaml}
{
	keywords={true,false,null,y,n},
	keywordstyle=\color{darkgray}\bfseries,
	basicstyle=\YAMLkeystyle,                                 % assuming a key comes first
	sensitive=false,
	comment=[l]{\#},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{purple}\ttfamily,
	stringstyle=\YAMLvaluestyle\ttfamily,
	moredelim=[l][\color{orange}]{\&},
	moredelim=[l][\color{magenta}]{*},
	moredelim=**[il][\YAMLcolonstyle{:}\YAMLvaluestyle]{:},   % switch to value style at :
	morestring=[b]',
	morestring=[b]",
	literate =    {---}{{\ProcessThreeDashes}}3
	{>}{{\textcolor{red}\textgreater}}1     
	{|}{{\textcolor{red}\textbar}}1 
	{\ -\ }{{\mdseries\ -\ }}3,
}

% switch to key style at EOL
\lst@AddToHook{EveryLine}{\ifx\lst@language\language@yaml\YAMLkeystyle\fi}
\makeatother

\newcommand\ProcessThreeDashes{\llap{\color{cyan}\mdseries-{-}-}}

% YAML definition - END


\lstnewenvironment{code}[2][]{%
	\lstset{%
		backgroundcolor=\color{gray!10},  
		basicstyle=\ttfamily,
		numbers=none, 
		breakatwhitespace=false,      
		breaklines=true,
		title   = #2,
		#1,
	}%
}{}

\usepackage{listings}
\lstdefinestyle{ascii-tree}{
	literate={├}{|}1 {─}{--}1 {└}{+}1 ,
	backgroundcolor=\color{gray!10},  
	basicstyle=\ttfamily,
	numbers=none
}
\usepackage{dirtytalk}

\usepackage[acronym]{glossaries}
\usepackage{placeins}

\makeglossaries

\newglossaryentry{tarea}{name=Tarea,description={Problema a resolver asignado a un estudiante o equipo}}
\newglossaryentry{insignia}{name=Insignia,description={Trofeo o Marcador que se obtiene al realizar cierta acción en la aplicación}}
\newglossaryentry{ede}{name=Equipo de Estudiantes,description={Grupo de uno o más estudiantes formado para resolver Tareas de forma conjunta}}
\newglossaryentry{gde}{name=Grupo de Estudiantes,description={Clase a la que pertenece el estudiante para el año lectivo}}
\newglossaryentry{edp}{name=Entorno de producción,description={lugar donde se ejecuta el aplicativo para los usuarios finales}}
\newglossaryentry{contenedor}{name={Contenedor},description={imagen ejecutable ligera y portátil que contiene el software y todas sus dependencias}}
\newglossaryentry{administrador}{name={Administrador},description={Usuario con un rol que le permite administrar el sistema, normálmente será el profesor de un curso académico}}
\newglossaryentry{alumno}{name={Alumno},description={Estudiante que forma parte de un curso académico}}
\newglossaryentry{equipo}{name={Equipo},description={Grupo de estudiantes que pertenecen a una misma clase en un grupo académico}}
\newglossaryentry{grupo}{name={Grupo},description={Agrupación de alumnos que pertenecen a un grupo académico}}
\newglossaryentry{cola}{name={Cola},description={Estructura de datos que sigue una filosofía FIFO}}
\newglossaryentry{clase}{name={Clase},description={Plantilla para la creación de objetos de datos según un modelo predeterminado}}
\newglossaryentry{paquete}{name={Paquete},description={Carpeta que contiene varios módulos de Python}}
\newglossaryentry{envio}{name={Envio},description={Petición web que incluye el código fuente a compilar y ejecutar como propuesta de solución a una Tarea}}

\newacronym{dsic}{DSIC}{Departamento de Sistemas Informáticos y Computación}
\newacronym{upv}{UPV}{Universitat Politècnica de València}
\newacronym{etsinf}{ETSINF}{Escuela Técnica Superior de Ingeniería Informática}
\newacronym{cpa}{CPA}{Computación Paralela}
\newacronym{lpp}{LPP}{Lenguajes y Entornos de la Programación Paralela}
\newacronym{tfg}{TFG}{Trabajo Final de Grado}
\newacronym{rf}{RF}{Requisito funcional}
\newacronym{rnf}{RNF}{Requisito no funcional}
\newacronym{gce}{GCE}{Google Cloud Engine}
\newacronym{bd}{BD}{Base de datos}
\newacronym{so}{SO}{Sistema operativo}
\newacronym{k8s}{K8s}{Kubernetes}
\newacronym{ram}{RAM}{Memoria de acceso aleatorio}
\newacronym{vcpus}{vCPUs}{Unidades centrales de procesamiento virtuales}
\newacronym{api}{API}{Interfaz de programación de aplicaciones}
\newacronym{gib}{GiB}{Gibibyte}
\newacronym{nfs}{NFS}{Sistema de archivos de red}
\newacronym{ssh}{SSH}{Secure Shell}
\newacronym{scp}{SCP}{Secure Copy}
\newacronym{fifo}{FIFO}{Primero en entrar, primero en salir}
\newacronym{mvc}{MVC}{Modelo Vista Controlador}
\newacronym{gii}{GII}{Grado de Ingeniería Informática}
\newacronym{cpu}{CPU}{Unidad central de procesamiento}


\usepackage{listings}


\title{Implementación de un sitio web para un concurso de programación paralela}
\author{Nicolás Fernando Martini}
\tutor{Pedro Alonso Jordá}
\curs{2019-2020}


\keywords{?, ?, ?, ?} 
         {programación paralela, concurso de programación, gamificación, ludificación}  
         {parallel programming, programming competition, gamification}       

\begin{document}
	

\begin{dedication}	
	
	\chapter*{Dedicatoria}
	
	...

	\chapter*{Agradecimientos}
		A mi tutor Pedro Alonso Jordá por su apoyo y la oportunidad de hacer este proyecto con la esperanza que produzca un impacto positivo en la enseñanza en los cursos venideros. \par
		A la ETSINF y todos sus profesores, gracias a ellos he podido crecer personal y profesionalmente. \par
		Al Ministerio de Educación y Gobierno de España, gracias a sus ayudas he podido acceder los estudios de grado.
		
\end{dedication}

\begin{abstract}

... \par

... \par

... \par

\end{abstract}

\begin{abstract}[spanish]
	
El presente trabajo aborda la implementación de un sitio web para concursos de programación paralela, con el añadido de la gamificación o ludificación, una técnica de aprendizaje que busca recompensar al usuario y aumentar su motivación al sumar elementos y dinámicas propias de los juegos para así ofrecer una experiencia enriquecedora y positiva. \par 

Esta es una tarea compleja, por un lado llevar el proceso de envío de código a un entorno web y la interacción que tendrá con el cluster \kahan del DSIC. Y por el otro, transformar las actividades de laboratorio de las asignaturas CPA y LPP con nuevas mecánicas que produzcan al estudiante buscar mejorar sus resultados inclusive después de llegar a una resolución correcta a los ejercicios planteados. \par

Este proyecto ha sido realizado con el apoyo del DSIC de la UPV con la finalidad de complementar otras herramientas utilizadas hoy en día en la enseñanza. \par


\end{abstract}

\begin{abstract}[english]

... \par

... \par

... \par

\end{abstract}

\mainmatter

\chapter{Introducción}

En este proyecto se trabajarán dos conceptos importantes, la programación paralela y la gamificación. \par

La programación paralela es una rama importante de la computación donde se buscar partir problemas de gran magnitud en pedazos más pequeños donde cada partición es ejecutada de forma simultanea por diferentes recursos computacionales de forma coordinada. Este tipo de ejecución tiene varias ventajas como la posibilidad de obtener soluciones a problemas que no pueden ser resueltos en un tiempo razonable, que tienen una orden y complejidad mayor, y que no podrían resolverse con el uso de una única . La programación paralela también trae sus desventajas como una mayor complejidad al escribir los programas, evitar condiciones de carrera y la sincronización entre los recursos. \par

La gamificación como estrategia para motivar al alumnado añadiendo elementos y estructuras propias de juegos como destacar en posiciones de clasificación, la competencia entre equipos y la obtención de premios. Estos añadidos estimulan y hacen más atractiva la participación de los estudiantes y así llegar a transformar las actividades de laboratorio de \acrfull{lpp}, asignatura de la rama de Computación, así como también a los de \acrfull{cpa}, asignatura obligatoria del tercer bloque; ambas del \acrfull{gii}. \par

El objetivo final es crear una herramienta de software (aplicación web) que acerque estos ``dos mundos`` y así crear a una experiencia que fomente la colaboración, incentive al alumnado en mejorar sus resultados y afianzar conceptos desde el marco de la competición.

\section{Motivación}

Desde el inicio de mis estudios en el \acrshort{gii} me han interesado los concursos de programación ya sean los promovidos desde la propia \acrshort{etsinf} así como también los disponibles en plataformas online como UVa\footnote{UVa Online Judge website: \url{https://onlinejudge.org/}}, HackerRank\footnote{HackerRank website: \url{https://www.hackerrank.com/}}, CheckIO\footnote{CheckIO website: \url{https://checkio.org/}} y Project Euler\footnote{Project Euler website: \url{https://projecteuler.net/}}. Estas competiciones ayudan a promover el interés en diferentes conceptos fundamentales que debe conocer cualquier profesional de las Ciencias de la Computación como son las estructuras de datos y la algoritmia con el añadido de un marco lúdico con elementos de lo que llamamos previamente gamificación. \par

Normalmente los concursos o competiciones de programación sólo buscan la resolución de una serie de problemas para un conjunto finito de entradas sin importar los tiempos de ejecución o su eficiencia. Por eso al ver la publicación de la propuesta del \acrfull{tfg} donde se añade la programación paralela me ha despertado el interés ya que también se premiará la eficacia del código en obtener una solución en el menor tiempo posible y el añadido de tener que trabajar con un elemento externo como lo es el \foreign{english}{cluster} \kahan del \acrfull{dsic}.  \par

Crear esta aplicación que podrán utilizar los alumnos en cursos venideros es mi principal motivación y forma de devolver a la Universidad todas las herramientas que me ha dado, haberme formado y ayudarme a convertirme en un profesional de la Informática. 

\section{Objetivo}

Desde mi punto de vista no existe un único objetivo al realizar un \acrfull{tfg}, mas allá de que el principal sea la implementación de un sitio web para concursos de programación paralela, hay otros puntos importantes a considerar como la documentación del proceso realizado, lo que se ha aprendido y que aportes puede brindar a la comunidad científica. \par 

Otros objetivos adicionales o secundarios pueden ser; el seguimiento de un proceso formal para el análisis, diseño, implantación y mantenimiento del software, siendo conceptos previamente vistos en la rama de Ingeniería de Software y esenciales en cualquier proyecto ingenieril. Ofrecer una herramienta \foreign{english}{open source} abierta a la colaboración, de uso libre y a disposición de otros centros de estudio. Y explorar nuevas herramientas utilizadas actualmente en el mercado ampliando así mis capacidades como profesional de la Informática.

\section{Estructura de la memoria}

La memoria recoge el proceso de ``desarrollo del software`` o ``ciclo de vida del software`` con bloques adicionales que forman parte de un \acrshort{tfg} como lo son el Estado del arte o las Conclusiones. Está dividida en los siguientes capítulos, cada uno con sus objetivos.

\begin{itemize}
	\item \textbf{Estado del arte}: análisis de las alternativas que existen al trabajo planteado. 
	\item \textbf{Análisis del problema}: recopilación de los requerimientos para así llegar a una propuesta que abarque las necesidades actuales de la asignatura \acrshort{lpp}.
	\item \textbf{Diseño de la solución}: descripción de los elementos que forman parte de la solución y el procese que se ha seguido para la elección de las herramientas utilizadas.
	\item \textbf{Desarrollo de la solución}: enfoque que se ha seguido para el desarrollo del software con sus entregables.
	\item \textbf{Implantación}: pasos a seguir para el despliegue de la solución en una plataforma \foreignlanguage{english}{cloud}.
	\item \textbf{Mantenimiento}: explicación de como configurar un entorno de desarrollo local, depurar errores y mantener una calidad de código aceptable. 
	\item \textbf{Extensibilidad}: formas en las cuales se puede añadir funcionalidades nuevas.
	\item \textbf{Conclusiones}: resultado final del \acrshort{tfg} y los objetivos alcanzados.
	\item \textbf{Trabajos futuros}: puntos interesantes a tratar en próximas iteraciones o nuevas versiones del software.
\end{itemize}

\chapter{Estado del arte}

\section{Crítica al estado del arte}


\chapter{Análisis del problema}

Como todo proyecto de desarrollo de software se debe seguir un modelo o proceso que garantice el éxito y la calidad del producto final. Siguiendo un proceso tradicional el primer paso es la ``toma de requisitos`` en el cual se realiza un análisis que involucra a los usuarios (Actores) que utilizarán el sistema, cada uno con sus necesidades (Requisitos). De este estudio se llegará una especificación funcional del software antes de comenzar a escribir siquiera una linea de código. Una vez terminada esta etapa se irán sucediendo las siguientes en próximos capítulos en el orden habitual de un modelo en cascada: toma de requisitos, diseño, implementación, implantación y mantenimiento.

\section{Actores}

El sistema contará con dos perfiles de usuarios que llamaremos actores, estos son el \Gls{alumno} y \Gls{administrador}. También veremos que en la memoria se hace mención al ``usuario`` (\foreign{english}{User}), esto se hace para referirnos a funcionalidades que se aplican tanto a los \gls{alumno}s como \gls{administrador}es

\begin{itemize}
	\item \textbf{\gls{alumno}}: el actor principal del sistema. Enviará soluciones a los problemas propuestos y tratará de mejorar sus resultados para subir su ranking en las tablas de posiciones. Su trabajo será recompensado en forma de puntos e insignias, que son trofeos o marcas obtenidas después de lograr cierto objetivo. Un alumno pertenecerá a un \gls{grupo} (\foreign{english}{Group}) que será el curso en el cual está matriculado y también podrá formar un \gls{equipo} (\foreign{english}{Team}) con sus compañeros de clase para resolver problemas en conjunto.
	\item \textbf{\gls{administrador}}: el actor que se encarga de poner el sistema en marcha. Tendrá que tener conocimientos sólidos en programación paralela para poder crear tareas que varíen en dificultad y motive al alumnado a mejorar sus resultados. Normalmente será el profesor de la asignatura \acrshort{lpp} o \acrshort{cpa}.
\end{itemize}

Antes de comenzar a listar las \textbf{Historias de usuario} hay un concepto importante a definir que es el de \gls{tarea} (\foreign{english}{Assignment}), este es un problema a resolver en la aplicación con una serie de entradas y resultado a obtener que el \gls{alumno} desconoce. Cuando en la memoria se haga mención a la palabra \foreign{english}{task} no nos referimos a una \gls{tarea} sino a un ``trabajo`` a procesarse en una cola (\foreign{english}{queue}) interna o de \kahan.

\section{Historias de usuario}

El primer paso es realizar una entrevista con los actores involucrados para describir el resultado esperado de este proyecto en un lenguaje sencillo que más adelante darán partida a los requisitos funcionales y no funcionales de la aplicación. A esto se le llama \textbf{Historias de usuario}. Para este caso en particular ambos actores fueron interpretados por el tutor y el autor del \acrshort{tfg} intercambiando roles al comienzo de la elaboración de la memoria.

\begin{itemize}
	\item Como \gls{alumno}, quiero ingresar al sistema utilizando mis credenciales personales.
	\item Como \gls{alumno}, quiero cambiar mi contraseña.
	\item Como \gls{alumno}, quiero registrarme en el sistema para poder hacer uso del mismo.
	\item Como \gls{alumno}, quiero enviar las resoluciones a mis \gls{tarea}s asignadas.
	\item Como \gls{alumno}, quiero formar parte de un equipo con otros \gls{alumno}s de mi \gls{grupo}.
	\item Como \gls{alumno}, quiero acceder a mi perfil para ver toda mi información.
	\item Como \gls{alumno}, quiero visualizar los resultados de las ejecuciones para ver como han quedado posicionadas en la tabla de clasificación.
	\item Como \gls{alumno}, quiero ver un resumen de mi actividad.
	\item Como \gls{administrador}, quiero crear \gls{grupo}s para que los \gls{alumno}s puedan formar parte de ellos.
	\item Como \gls{administrador}, quiero crear \gls{alumno}s subiendo un fichero csv o txt.
	\item Como \gls{administrador}, quiero crear y asignar \gls{tarea}s a diferentes \gls{grupo}s.
	\item Como \gls{administrador}, quiero crear \gls{insignia}s para asignar a \gls{tarea}s.
	\item Como \gls{administrador}, quiero editar y eliminar \gls{grupo}s, \gls{alumno}s, \gls{tarea}s e \gls{insignia}s.
	\item Como \gls{administrador}, quiero poder configurar la aplicación.
	\item Como \gls{administrador}, quiero desplegar la aplicación en una solución \foreign{english}{cloud}.
\end{itemize}

\section{Requisitos funcionales}

Una vez identificadas las \textbf{Historias de Usuario} más importantes el próximo paso es convertirlas en requisitos funcionales formales , específicos y consistentes. Esto evitará ambigüedades y dejará por sentado como se comportará el sistema. Aquí se describen todos los requisitos funcionales del aplicativo siguiendo una plantilla estandarizada con los siguientes campos:

\begin{itemize}
	\item \textbf{Nombre}: título del requerimiento funcional.
	\item \textbf{Descripción}: objetivo que debe cumplir el requisito.
	\item \textbf{Prioridad}: nivel de importancia. Mientras más alto sea se le dará preferencia sobre otros requisitos.
	\item \textbf{Criterio de aceptación}: condiciones que se deben cumplir o satisfacer para que el requisito se considere cumplido.
\end{itemize}

Además, para dar un seguimiento durante la etapa de desarrollo, pruebas y entrega final se le añade un identificador único.

\begin{table}[!ht]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-1}} \\
		\hline
		Nombre & Registro de usuarios\\
		\hline
		Descripción & El sistema permitirá el registro de usuarios mediante dirección de correo electrónico   \\
		\hline
		Prioridad & Media\\
		\hline
		Criterio de aceptación & 
		\begin{tabitem}
			\item no puede existir más de un usuario con el mismo correo electrónico
			\item se generará un usuario único con el alias del correo electrónico
			\item se podrá deshabilitar el registro de usuarios mediante configuración del sistema
			\item se podrá limitar el registro de usuarios a correos electrónicos que pertenezcan a dominios específicos (eg: @upv.es, @inf.upv.es)
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-1 Registro de usuarios}
	\label{table:1}
\end{table}

\begin{table}[!ht]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-2}} \\
		\hline
		Nombre & Ingreso de usuarios\\
		\hline
		Descripción & El sistema permitirá el ingreso de usuarios mediante dirección de correo electrónico o nombre de usuario  \\
		\hline
		Prioridad & Más Alta\\
		\hline
		Criterio de aceptación & 
		\begin{tabitem}
			\item solo se podrá ingresar al sistema si la cuenta está activa
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-2 Ingreso de usuarios}
	\label{table:2}
\end{table}

\begin{table}[!ht]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-3}} \\
		\hline
		Nombre & Equipos\\
		\hline
		Descripción & Los \gls{alumno}s podrán formar parte de un \gls{equipo} con otros compañeros de \gls{grupo}  \\
		\hline
		Prioridad & Baja\\
		\hline
		Criterio de aceptación & 
		\begin{tabitem}
			\item solo se podrá formar parte de un único \gls{equipo} en un momento determinado de tiempo
			\item si un \gls{equipo} no tiene integrantes se eliminará del sistema
			\item los \gls{equipo}s contarán con una URL única que permitirá a otros \gls{alumno}s unirse a los mismos
			\item un \gls{alumno} no puede unirse un \gls{equipo} que no forme parte de su \gls{grupo} o que haya llegado al máximo de integrantes
			\item los \gls{equipo}s tendrán un máximo de integrantes que podrá ser configurado por el \gls{administrador}
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-3 Equipos}
	\label{table:3}
\end{table}


\begin{table}[!ht]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-4}} \\
		\hline
		Nombre & Página de Inicio\\
		\hline
		Descripción & Los \gls{alumno}s al ingresar verán un resumen agregado de su estado general en la aplicación   \\
		\hline
		Prioridad &  Alta\\
		\hline
		Criterio de aceptación & La Página de Inicio (\foreign{english}{Dashboard}) del \gls{alumno} deberá mostrar la siguiente información: \newline
		\begin{tabitem}
			\item resumen de los últimos envíos
			\item extracto calculado de cantidad de envíos, tareas, \foreign{english}{quota} disponible (porcentaje de tiempo restante de ejecución) y puntaje
			\item la última insignia obtenida, en caso que no tuviere, alentarlo a completar una tarea para conseguir su primera
			\item los integrantes del equipo, en caso que no tuviere, alentarlo a crear uno nuevo o unirse a uno existente
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-4 Página de Inicio}
	\label{table:4}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-5}} \\
		\hline
		Nombre & Mis Envíos \\
		\hline
		Descripción & Los \textit{usuarios}, \gls{administrador}es como \gls{alumno}s, podrán ver un resumen de sus \gls{envio}s (peticiones web que incluyen el código fuente a ejecutar) \\
		\hline
		Prioridad & Muy Alta\\
		\hline
		Criterio de aceptación & El resumen de \gls{envio}s se visualizará en forma de tabla, se podrá filtrar por la información disponible y deberá mostrar las siguientes columnas: \newline
		\begin{tabitem}
			\item ID único en el sistema
			\item Fecha y Hora de envío
			\item Tarea a la que corresponde
			\item Estado del envío
			\item Puntaje obtenido
			\item Tiempo de ejecución
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-5 Mis Envíos}
	\label{table:5}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-6}} \\
		\hline
		Nombre & Visualización de Envío \\
		\hline
		Descripción & Al realizar un \gls{envio}, un \textit{usuario} podrá navegar a una URL única para ver toda la información disponible y hacer el seguimiento de su estado  \\
		\hline
		Prioridad & Alta\\
		\hline
		Criterio de aceptación & Se deben mostrar los siguientes apartados e información y cumplir con las siguientes restricciones y funcionalidades: \newline  
		\begin{tabitem}
			\item código fuente
			\item análisis estático del código fuente enviado
			\item resultado del código ejecutado (\foreign{english}{outout} de la consola o terminal)
			\item tiempo de ejecución y status
			\item cada \gls{envio} tiene un ID único que no puede ser repetido en el sistema
			\item un \gls{envio} solo puede ser visualizado por el autor o un \textit{usuario} con Rol de \gls{administrador} 
		\end{tabitem}  \\
		\hline
	\end{tabular}
	\caption{RF-6 Visualización de Envío}
	\label{table:6}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-7}} \\
		\hline
		Nombre & Visualización de Tareas \\
		\hline
		Descripción  & Todos los \textit{usuarios} podrán acceder a un apartado donde se muestre un listado en forma de resumen de las \gls{tarea}s disponibles \\
		\hline
		Prioridad &  Alta\\
		\hline
		Criterio de aceptación & Se deben mostrar los siguientes apartados e información: \newline  
		\begin{tabitem}
			\item si el usuario es un \gls{alumno} se deben mostrar las tareas asignadas a su grupo
			\item si el usuario es un \gls{alumno} se deben mostrar todas las tareas en el sistema
			\item por cada \gls{tarea} debe haber un resumen, insignias y últimos envíos
			\item no se deben mostrar las \gls{insignia}s secretas
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-7 Visualización de Tareas}
	\label{table:7}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-8}} \\
		\hline
		Nombre & Tarea \\
		\hline
		Descripción  & Visualización de Tarea a completar con su descripción completa \\
		\hline
		Prioridad &  Alta\\
		\hline
		Criterio de aceptación & Se deben mostrar los siguientes apartados e información: \newline  
		\begin{tabitem}
			\item descripción completa
			\item \gls{insignia}s a obtener
			\item \gls{insignia}s secretas que el usuario ha obtenido
			\item status de la \gls{tarea}: abre pronto, abierto, cierra pronto, cerrada
			\item si el \textit{usuario} ha realizado un \gls{envio} que ha finalizado una ejecución satisfactoria se le debe informar en un mensaje
			\item enlace para hacer un envío con sus credenciales
			\item enlace a la tabla de posiciones
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-8 Tarea}
	\label{table:8}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-9}} \\
		\hline
		Nombre   & FAQ \\
		\hline
		Descripción  & Página con preguntas frecuentes que se pueden hacer los usuarios del sistema y sus respuestas  \\
		\hline
		Prioridad &  Baja\\
		\hline
		Criterio de aceptación & 
		\begin{tabitem}
			\item debe estar localizado en al menos 2 idiomas
			\item no debe contener más de 10 preguntas
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-9 FAQ}
	\label{table:9}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-10}} \\
		\hline
		Nombre & Tabla de Posiciones \\
		\hline
		Descripción & Página en la cual se muestran las posiciones por \gls{tarea} y \gls{grupo} en formato de tabla\\
		\hline
		Prioridad & Alta\\
		\hline
		Criterio de aceptación & 
		\begin{tabitem}
			\item los \gls{alumno}s solo pueden visualizar las tablas de posiciones de sus \gls{tarea}s asignadas y el \gls{grupo} al que pertenecen
			\item los \gls{administrador}es pueden filtrar las tablas de posiciones por \gls{grupo}s
			\item la posición de un \gls{envio} en una \gls{tarea} está dada por el tiempo de ejecución, a menor tiempo de ejecución, mejor posicionada
			\item la posición de un \gls{alumno} en una tabla de posición de \gls{grupo} está dada por la cantidad de puntos que lleva acumulado, mientras más puntos, mejor posición
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-10 Tabla de Posiciones}
	\label{table:10}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-11}} \\
		\hline
		Nombre & Perfil \\
		\hline
		Descripción & Un \textit{usuario} del sistema tiene su perfil donde puede ver un resumen de su actividad, cambiar su contraseña, ver al \gls{grupo} al que pertenece, cambiar el token de \gls{envio} de \gls{tarea}s y su puntaje acumulado  \\
		\hline
		Prioridad & Media\\
		\hline
		Criterio de aceptación & Se debe mostrar la siguiente información: \newline
		\begin{tabitem}
			\item aparado con un resumen de actividad con los \gls{envio}s realizados y las \gls{insignia}s obtenidas
			\item apartado para cambiar la contraseña
			\item apartado para generar un nuevo token
			\item apartado para ver los integrantes de su \gls{grupo}
			\item apartado de \gls{insignia}s obtenidas
			\item un resumen de los puntos acumulados y cantidad de \gls{envio}s realizados
			\item equipo al que pertenece con sus integrantes
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-11 Perfil}
	\label{table:11}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-12}} \\
		\hline
		Nombre & Configuración del Sistema \\
		\hline
		Descripción & Apartado con el resumen de todos los parámetros de despliegue de la aplicación \\
		\hline
		Prioridad & Baja\\
		\hline
		Criterio de aceptación & Se debe mostrar en forma de tabla todos los parámetros de despliegue de la aplicación en formato clave:valor. Esta página solo puede ser accedida por un \gls{administrador} \\
		\hline
	\end{tabular}
	\caption{RF-12 Configuración del Sistema \\}
	\label{table:12}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-13}} \\
		\hline
		Nombre & Administración de Envíos \\
		\hline
		Descripción & Página con un listado de todos los \gls{envio}s que han sido procesados por el sistema \\
		\hline
		Prioridad & Alta\\
		\hline
		Criterio de aceptación & Solo los \gls{administrador}es pueden acceder a esta página. \newline 
		El listado de \gls{envio}s debe contener la siguiente información \newline
		\begin{tabitem}
			\item ID único del sistema con su URL única
			\item fecha y hora de envío
			\item \textit{usuario} que ha realizado el \gls{envio} con su correo y grupo al que pertenece si es un \gls{alumno}
			\item \gls{tarea} a la cual pertenece el \gls{envio}
			\item \foreign{english}{status} del \gls{envio} (en espera, encolado, en ejecución, error, etc..)
			\item puntos que se han asignado al \gls{envio}
			\item tiempo de ejecución
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-13 Administración de Envíos}
	\label{table:13}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-14}} \\
		\hline
		Nombre & Administración de Grupos \\
		\hline
		Descripción & Página con un listado de los \gls{grupo}s de \gls{alumno}s \\
		\hline
		Prioridad & Media\\
		\hline
		Criterio de aceptación & 
		Se debe poder crear nuevos \gls{grupo}s con un código único y descripción, además de poder eliminarlos. \newline
		Solo los \gls{administrador}es pueden acceder a esta página. \newline
		El listado debe contener la siguiente información \newline
		\begin{tabitem}
			\item código único
			\item descripción
			\item cantidad de \gls{alumno}s asignados al \gls{grupo}
			\item listado de \gls{tarea}s asignadas al \gls{grupo}
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-14 Administración de Grupos}
	\label{table:14}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-15}} \\
		\hline
		Nombre & Administración de colas internas \\
		\hline
		Descripción & Página con información del estado de las colas internas de la aplicación \\
		\hline
		Prioridad & Alta\\
		\hline
		Criterio de aceptación & Solo los \gls{administrador}es pueden acceder a esta página. \newline
		Debe mostrarse una resumen con la siguiente información y funcionalidades: \newline
		\begin{tabitem}
			\item colas internas disponibles y su estado
			\item información sobre las \foreign{english}{tasks} encoladas y en espera
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-15 Administración de colas internas \\}
	\label{table:15}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-16}} \\
		\hline
		Nombre & Administración de Alumnos \\
		\hline
		Descripción & página con un listado de todos los \gls{alumno}s del sistema  \\
		\hline
		Prioridad & Alta\\
		\hline
		Criterio de aceptación & Solo los \gls{administrador}es pueden acceder a esta página. \newline
		Se debe poder borrar \gls{alumno}s del sistema y resetear sus contraseñas. \newline
		El listado de \gls{alumno}s debe contener la siguiente información: \newline
		\begin{tabitem}
			\item nombre de usuario, correo y nombre
			\item grupo al que pertenece
			\item \foreignlanguage{english}{quota} disponible
			\item puntos
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-16 Administración de Alumnos}
	\label{table:16}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-17}} \\
		\hline
		Nombre & Administración de Tareas \\
		\hline
		Descripción & Página con listado de todas las \gls{tarea}s disponibles en el sistema en formato de tabla  \\
		\hline
		Prioridad & Alta\\
		\hline
		Criterio de aceptación & Solo los \gls{administrador}es pueden acceder a esta página. \newline
		Posibilidad de crear una nueva \gls{tarea}. \newline
		La información que debe mostrar la tabla es la siguiente: \newline
		\begin{tabitem}
			\item ID único
			\item status de la \gls{tarea}: abierta o cerrada
			\item nombre
			\item título
			\item cantidad de \gls{envio}s
			\item fecha de inicio y fin
			\item \gls{grupo}s a la cual está asignada
			\item URL para la edición
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-17 Administración de Tareas}
	\label{table:17}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-18}} \\
		\hline
		Nombre & Creación y edición de Tarea \\
		\hline
		Descripción & Página donde se puede crear una nueva \gls{tarea} o editar una ya existente en el sistema con un editor HTML para la descripción de la misma \\
		\hline
		Prioridad & Muy Alta\\
		\hline
		Criterio de aceptación & Solo los \gls{administrador}es pueden acceder a esta página. \newline
		Se puede eliminar una \gls{tarea} desde la edición. \newline
		Se debe poder insertar código fuente para una mejor visualización en la descripción. \newline
		Se pueden añadir ficheros adjuntos que serán copiados al cluster \kahan junto al código fuente a ejecutar de un \gls{envio}. \newline
		Los campos disponibles en la creación o edición de una \gls{tarea} son los siguientes: \newline
		\begin{tabitem}
			\item nombre único
			\item título
			\item fecha de inicio y fin
			\item puntos a asignar en caso de un resultado satisfactorio
			\item editor texto para la descripción de la \gls{tarea} en formato HTML
			\item resultado esperado de la ejecución
			\item listado de \gls{grupo}s a asignar la tarea
			\item listado de \gls{insignia}s que se pueden obtener en la \gls{tarea}
			\item ficheros adjuntos
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-18 Creación y edición de Tarea}
	\label{table:18}
\end{table}

\FloatBarrier

\section{Requisitos no funcionales}

Los requisitos no funcionales son criterios que se deben cumplir para juzgar la correcta operación del sistema. En contraste con los requisitos funcionales no definen comportamientos específicos. \par

Para las siguientes tablas también se ha creado una plantilla estándar similar a la de requisitos funcionales pero con menos atributos. La definición de los mismos es la misma de las tablas vistas anteriormente.

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RNF-1}} \\
		\hline
		Nombre   & Usabilidad \\
		\hline
		Descripción  & El sitio web deberá tener una interfaz sencilla y fácil de utilizar. \\
		\hline
		Prioridad &  Muy Alta \\
		\hline
	\end{tabular}
	\caption{RNF-1 Usabilidad}
	\label{table:19}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RNF-2}} \\
		\hline
		Nombre   & Implantación \\
		\hline
		Descripción  & El aplicativo debe poder implantarse de forma automatizada \\
		\hline
		Prioridad &  Media \\
		\hline
	\end{tabular}
	\caption{RNF-2 Implantación}
	\label{table:20}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RNF-3}} \\
		\hline
		Nombre   & Configuración \\
		\hline
		Descripción  & El aplicativo debe permitir configurar los parámetros de despliegue y uso \\
		\hline
		Prioridad &  Alta \\
		\hline
	\end{tabular}
	\caption{RNF-3 Configuración}
	\label{table:21}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RNF-4}} \\
		\hline
		Nombre   & Localización \\
		\hline
		Descripción  & El aplicativo debe soportar la localización en diferentes idiomas \\
		\hline
		Prioridad &  Media \\
		\hline
	\end{tabular}
	\caption{RNF-4 Localización}
	\label{table:22}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RNF-5}} \\
		\hline
		Nombre & Almacenamiento \\
		\hline
		Descripción  & Toda la información de la aplicación debe ser persistida en una \acrfull{bd} y el código fuente almacenado en un sistema de ficheros \\
		\hline
		Prioridad &  Muy alta \\
		\hline
	\end{tabular}
	\caption{RNF-5 Almacenamiento}
	\label{table:23}
\end{table}


\section{Cluster Kahan}

\kahan es un \foreign{english}{cluster} de computación perteneciente a la \acrshort{upv} y será el encargado de procesar el código envíen los alumnos a la aplicación web. Consta de un nodo cabecera (\textit{Frontend}) a la que un usuario se puede conectar mediante escritorio remoto o consola y así enviar el trabajo a procesar en alguna de sus colas. El nodo \textit{Frontend} es el encargado de comunicarse con el \foreign{english}{cluster} de 6 nodos y procesar los envíos.


\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.8\textwidth]{img/kahan-cluster}
	\caption[Diagrama del cluster \kahan]{Diagrama del cluster \kahan}
	\label{figura:kahan-cluster}
\end{figure}

En las practicas de las asignaturas de \acrshort{lpp} y \acrshort{cpa} la ejecución de los pasos de conexión al \textit{Frontend}, envío de código a una cola, revisión de estado de la ejecución y descarga de resultados es un proceso completamente manual que inclusive llega a ser tedioso. Y Por esto uno de los puntos más importantes y complejos que vale la pena remarcar será lograr que la aplicación se encargue de la comunicación con el \foreign{english}{cluster} realizando el proceso completo de forma automatizada, añadiendo también la verificación de resultados y así ofrecer una mejor experiencia de usuario. El proceso interacción con el \foreign{english}{cluster} \kahan debe ser asíncrono y no bloquear el funcionamiento de la aplicación, y la mejor forma de lograr esto es hacer que la aplicación tenga un \textit{Administrador de Tareas} que en la práctica es un sistema de colas donde se envían ``trabajos`` (\foreign{english}{tasks}) a procesarse en un determinado momento de tiempo.

\section{Riesgos}

Un análisis de riesgo también forma parte del estudio del problema ya que se debe evaluar si el resultado esperado es realizable en tiempo y forma. Para el listado anterior se pueden identificar tres puntos críticos ya que tienen una complejidad alta.

Por un lado la interacción con el \foreign{english}{cluster} \kahan puede ser dificultosa porque lo haremos desde un sistema externo, además hay que sumarle la posibilidad de que la aplicación se despliegue en una solución \foreign{english}{cloud} siendo el autor de la memoria un usuario novel de esos sistemas. Y por último la verificación de resultados, asignación de \gls{insignia}s y tablas de posiciones (\foreign{english}{Leaderboards}) que pueden ir cambiando en el tiempo.

\chapter{Diseño de la solución}

Una vez analizados los requisitos funcionales y no funcionales el próximo paso es hacer el diseño de la aplicación. Aunque la finalidad de este trabajo es la creación de una aplicación web existen elementos adicionales que deben considerarse para cumplir con el objetivo, ya que aunque el punto de entrada de interacción del sistema será una página web toda la información se tendrá que alojar en una \acrfull{bd}, los \gls{envio}s que contienen ficheros con código fuente para la resolución de \Gls{tarea}s deberán guardarse en un \acrfull{nfs}. Todos estos elementos y más forman parte de lo que será la \textbf{Arquitectura de la solución} pero antes de llegar a esto hay que comprender como será la \textbf{Interacción del Sistema} y decidirse en el \textbf{Software} a utilizar que lo haga posible. \par

Además para alojar y recuperar información de una \acrshort{bd} debemos crear unos modelos que representen a todos los objetos que interactúan en el sistema, esto se llama el \textbf{Modelo de Datos}. Y por último la interacción con \kahan es tan importante que tendremos incluir un \textit{Administrador de Tareas} para el procesamiento de \foreign{english}{tasks} de forma asíncrona como un \textbf{Sistema de Colas interno}.

\section{Interacción del Sistema}

En la introducción del capítulo se han visto algunos elementos de la aplicación y es importante realizar un bosquejo de cómo será la interacción entre ellos para modelar la solución de forma correcta. Haciendo un repaso podemos encontrar los siguientes:

\begin{itemize}
	\item la aplicación web con la que interactúan los usuarios.
	\item la \acrfull{bd} donde se guarda la información.
	\item un \acrlong{nfs} para alojar los ficheros con código fuente de los \gls{envio}s.
	\item un \textit{Administrador de Tareas} basado en un sistema de colas interno.
	\item el \foreign{english}{cluster} kahan.
\end{itemize} 

Una interacción habitual sería la que se modela a continuación donde el \textit{Administrador de Tareas} es el encargado de todas las interacciones con el sistema de colas de \kahan para actualizar el \foreign{english}{status} del \gls{envio}. A partir de aquí ya queda claro la importancia de una separación de roles entre lo que será el \foreign{english}{frontend} o punto de interacción de los usuarios con la aplicación y el procesamiento de \gls{envio}s. Esto tendrá vital importancia en la elección del software a utilizar.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.95\textwidth]{img/modelado-interaccion}
	\caption[Modelado Interacción entre elementos del sistema]{Interacción entre elementos del sistema}
	\label{figura:modelado-interaccion}
\end{figure}

\section{Software}

Como hemos visto en el apartado \textbf{Estado del Arte} la única herramienta similar a la aplicación web a desarrollar es \textit{Tablón}, no sin sus muchas limitaciones y problemas que ya hemos expuesto previamente. Sin embargo \textit{Tablón} es un buen punto de partida porque ya ha sido utilizado previamente por el Tutor en la asignatura de \acrshort{lpp} y algunos de los requisitos funcionales como la Tabla de Posiciones (RF-10) ya existen y pueden servir como inspiración.

Dadas las limitaciones que tiene \textit{Tablón} una de las aspiraciones en la creación de ésta aplicación web para concursos de programación paralela es que sea su sucesor (o reemplazo) a futuro. Por esto mismo he decidido llamar a la aplicación web \textit{Pizarra} en honor a \textit{Tablón} y de aquí en adelante cuando se nombre \textit{Pizarra} se hace referencia a la aplicación web y otros elementos adicionales necesarios para su funcionamiento. 

El lenguaje de programación a utlizar será \textit{python}, ya conocido por el Autor y con una extensa cantidad de \gls{paquete}s, que son librerías que añaden funcionalidades extra y que serán de gran utilidad para acelerar los tiempos de desarrollo. Dado que ya hemos abordado la \textbf{Interacción del Sistema} a alto nivel solo resta escoger el \textbf{Software} que dará vida a la aplicación web y al \textit{Administrador de Tareas}.



\section{Arquitectura del Sistema}



\section {Modelo de datos}

Uno de los \Gls{paquete}s más importantes utilizados en la aplicación es \textit{SQLAlchemy} que permite mapear los objetos de Python a una base de datos de tipo relacional. \textit{SQLAlchemy} soporta varios motores de base de datos, entre otros SQLite, MySQL, PostgreSQL, Oracle o MS SQL. En este caso se optará por SQLite para el entorno de desarrollo local (se crea el fichero \textit{database.db} en el directorio raiz del aplicativo) y PostgreSQL para un entorno productivo dado que son de libre uso.

Dados los requerimientos funcionales, se han identificado y creado las siguientes clases de Python que mediante el uso de \textit{SQLAlchemy} podrán ser persistidos, consultados y actualizados en la \acrfull{bd}.

\begin{itemize}
	\item User: usuario del sistema
	\item Role: roles del sistema, en este caso Alumno y Administrador
	\item Team: alumnos que forman un equipo
	\item ClassGroup: grupo de alumnos que representan una clase en particular
	\item Badge: \Gls{insignia}  obtenida al completarse objetivos
	\item Request: envío de solución de un usuario a una \Gls{tarea}
	\item Assignment: \Gls{tarea} a resolver, puede estar asignada a uno o más grupos
	\item LeaderBoard: marcador de posiciones para una \Gls{tarea} y \Gls{grupo} particular
	\item Attachment: fichero adjunto añadido a una \Gls{tarea}	
	\item Task: tarea a procesar, utilizada por la \Gls{cola} interna de \textit{Pizarra}
\end{itemize}

Los modelos expuestos previamente se pueden encontrar en el fichero \textbf{models.py} siguiendo el estándar en \textit{Flask} y se expresan como clases en Python que extienden de la clase \textit{db.Model} del paquete de SQLAlchemy, esto permite la serialización del objeto y su persistencia en la \Gls{bd}. 

A continuación como ejemplo la representación de un equipo:

\begin{code}{models.py}
	...
	class Team(db.Model):
	"""
	Represents a Team of students in the database
	A Student can be a part of only one team
	A Team can have many students
	"""
	__tablename__ = 'team'
	id = Column(Integer, primary_key=True)
	name = Column(String, unique=True)
	key = Column(String)
	members = relationship('User', back_populates='team')
	...
\end{code}

En el código expuesto se puede identificar los siguientes elementos

\begin{itemize}
	\item la clase \textit{Team} extendiendo la clase \textit{db.Model}
	\item una descripción de la clase y su propósito
	\item el nombre de la tabla para persistir el objeto una vez serializado
	\item las diferentes columnas de la tabla con sus atributos (si es clave primaria, clave única y el tipo de datos)
	\item la relación entre \textit{Team} y \textit{User}. Un equipo tiene miembros y un usuario es parte de un equipo.
\end{itemize}

Una vez definidos todos los objetos con sus relaciones podemos generar un diagrama UML de la \Gls{bd}, esto facilita la comprensión y ofrece una mejor visión general.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.95\textwidth]{img/database-uml-diagram}
	\caption[Diagrama UML de la Base de Datos]{Diagrama UML de la Base de Datos}
	\label{figura:database-uml-diagram}
\end{figure}

\subsection{Paquetes de Python}

Python será el lenguaje a utilizar, pero para dar funcionalidades adicionales normalmente se utilizan librerías o \Gls{paquete}s externos que simplifican y aceleran el desarrollo de la solución. A continuación se hace un repaso de las librerías que son necesarias para \textit{Pizarra}, este listado se encuentra disponible en el fichero \textbf{requirements.txt}, un estandar utilizado para su fácil instalación a posteriori por administradores de paquetes como \textit{pip}.
	
\subsubsection{Flask}

El framework base de la aplicación, con otros \Gls{paquete}s para dar soporte a ciertas funcionalidades no incluidas en la librería base.

\begin{itemize}
	\item flask: framework
	\item flask\_login: funcionalidades extras para el manejo de sesiones de usuario
	\item flask\_security: uso de roles en el sistema  
	\item flask\_wtf: validación de formularios web
	\item flask\_sqlalchemy: soporte a SQLAlchemy para el mapeo objeto-relacional a diferentes \acrshort{bd}
	\item flask\_migrate: migración de base de datos basadas en SQLAlchemy
	\item flask-babel: localización de la aplicación en diferentes idiomas
	\item email-validator: validación de correos electrónicos para la librería wtf
\end{itemize}

\subsubsection{Colas}

Existen varios sistemas de \Gls{cola}s en Python, en este caso se ha optado por uno que utiliza pocos recursos y permite encolar tareas a ejecutar en cierto determinado de tiempo en el futuro, funcionalidad que será útil para revisar los resultados de ejecuciones en \kahan. \textit{RQ}\footnote{Sitio web RQ: \url{https://python-rq.org/}} (Redis Queue) permitirá desacoplar las colas del aplicativo web al utilizar \textit{Redis} además de disponer de un \foreignlanguage{english}{dashboard} que puede ser embebido en cualquier aplicación web.

\begin{itemize}
	\item rq: librería de Redis Queue
	\item rq-dashboard: visualización web del estado de \Gls{cola}s y \Gls{tarea}s
	\item redis: soporte y conectividad a Redis 
\end{itemize}

\subsubsection{Datos de ejemplo}

Para facilitar el desarrollo y su posterior mantenimiento se debe poder disponer de una forma fácil y estandarizada para carga de datos de ejemplo. Para esta funcionalidad se ha optado por ficheros \textit{yaml}.

\begin{itemize}
	\item pyyaml: analizador de ficheros \textit{yaml} 
	\item sqla-yaml-fixtures: definición de datos via \textit{yaml} para su posterior importación a SQLAlchemy
\end{itemize}

\subsubsection{Conexión con sistemas externos}

Para poder utilizar las \Gls{cola}s de \kahan es necesario poder conectarnos vía protocolos seguros ya sea para ejecutar comandos o copiar ficheros.

\begin{itemize}
	\item paramiko: soporte de protocolo \acrshort{ssh}
	\item scp: soporte de protocolo \acrshort{scp}
\end{itemize}

\subsubsection{Otros}

\begin{itemize}
	\item gunicorn: ejecución y monitoreo de la aplicación
	\item lizard: analizador de código estático
	\item rule\_engine: evaluador de reglas con expresiones lógicas, utilizado para asignar \Gls{insignia}s
\end{itemize}

\section{Diseño de la Aplicación en Flask}

Al crear una nueva aplicación en \textit{Flask} existen ciertos patrones o mejores prácticas a seguir, entre ellas se encuentra uno de los patrones de diseño más comunes en la ingeniería de software, \acrlong{mvc} (\acrshort{mvc}). Con este patrón se crea una separación de capas entre lo que es el Modelo que contiene la representación de datos y persistencia, la Vista que es la interfaz de usuario y el Controlador como intermediario entre el Modelo y la Vista.

Una aplicación estándar en \textit{Flask} inluye los siguientes ficheros:

\begin{itemize}
	\item models.py: representación del modelo de datos (Modelo)
	\item templates: carpeta con las plantillas HTML para la generación de páginas web (Vista)
	\item routes.py: rutas de acceso a la aplicación (Controlador)
	\item \_\_init\_\_.py: inicialización de la aplicación y librerías
	\item forms.py: formularios y validación
\end{itemize}

Además, otra buena práctica es separar las aplicaciones en módulos para añadir extensibilidad mediante reglas, nuevas vistas, separación de roles y otros beneficios añadidos mediante el uso de \foreignlanguage{english}{blueprints}.

De esta forma se ha optado por crear los siguientes módulos o \foreignlanguage{english}{blueprints}, todos estos dentro del directorio \textbf{app}:

\begin{itemize}
	\item account: apartado de ``mi cuenta`` de un usuario
	\item admin: panel de control del administrador, solo accesible para usuarios con ese rol
	\item base: contiene la definición de Modelos y plantillas base.
	\item data: importación de datos de ejemplo
	\item home: \foreignlanguage{english}{dashboard} de usuario
\end{itemize}

Si se lista el directorio \textbf{app} se puede ver como cáda módulo contiene una estructura de datos similar, siguiendo el estándar descrito previamente.


\begin{lstlisting}[style=ascii-tree]
$ tree -L 2 app/
app/
├── __init__.py
├── account
			├── __init__.py
			├── forms.py
			├── routes.py
			└── templates
├── admin
			├── __init__.py
			├── forms.py
			├── routes.py
			└── templates
├── base
			├── __init__.py
			├── forms.py
			├── models.py
...
\end{lstlisting}



\section{Envío de soluciones de Tareas}

Cuando un \Gls{alumno} realiza un \Gls{envio}, esto es, una petición web que incluye el código fuente a compilar y ejecutar como propuesta de solución a una \Gls{tarea}, la aplicación debe procesar la petición y el \Gls{envio} pasa por una serie de verificaciones que se describen a continuación, algunas de estas no se realizan para un usuario con rol de administrador del sistema.

\begin{enumerate}
	\item se autentifica al usuario
	\item se busca la \Gls{tarea} en la \Gls{bd}
	\item la \Gls{tarea} debe estar abierta a recibir \Gls{envio}s
	\item el \Gls{alumno} pertenece a un \Gls{grupo} que la tenga asignada
	\item el \Gls{alumno} no ha enviado peticiones muy rápido
	\item el \Gls{alumno} tiene Quota (tiempo disponible de ejecución) para procesar el \Gls{envio}
	\item el \Gls{envio} contiene un fichero a procesar
	\item el fichero a procesar con el código fuente no contiene código malicioso
\end{enumerate}

Si alguno de los pasos anteriores no pasa uno de los puntos de verificación se devuelve un mensaje de error con el código HTTP correspondiente. En el caso de que todas las checkeos sean satisfactorios se crea un objeto de tipo \textit{Request} en la \acrshort{bd} y otro de tipo \textit{Task} para la \Gls{cola} interna en Redis.

El \Gls{envio} de una \Gls{tarea} se realiza desde un terminal de comandos u otro cliente que permita enviar peticiones web como \textit{Postman} y está construida para devolver respuestas en formato JSON ya que es un estándar utilizado en muchas aplicaciones web. Un \Gls{envio} contiene como parámetros el usuario, token de acceso, fichero a procesar con el código fuente y la URL de la \Gls{tarea}, al procesarse la petición se recibe la respuesta.

A continuación varios ejemplos; Una autentificación fallida, un \gls{envio} satisfactorio y un \Gls{envio} no procesado porque el usuario debe esperar un tiempo.

\begin{lstlisting}[style=ascii-tree]
$ curl -k -X POST -F 'file=@primos.c' http://foo:bar@127.0.0.1:5000/assignments/primos
{
	"code": 401,
	"message": "Authentication failed"
}
$ curl -k -X POST -F 'file=@primos.c' http://foo:gB8HSgWANT7x7OipnFIkFQkC1sVLpO@127.0.0.1:5000/assignments/primos
{
	"code": 201,
	"message": "Request created, please navigate to http://127.0.0.1:5000/requests/13 to check the results"
}
$ curl -k -X POST -F 'file=@primos.c' http://foo:gB8HSgWANT7x7OipnFIkFQkC1sVLpO@127.0.0.1:5000/assignments/primos
{
	"code": 403,
	"message": "You are sending Requests too fast. Time between Requests is 60 seconds"
}
\end{lstlisting}

El diagrama de flujo de una petición web es el siguiente:

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.8\textwidth]{img/request-flowchart}
	\caption[Diagrama de flujo de una petición web para un Envío]{Diagrama de flujo de una petición web para un Envío}
	\label{figura:request-flowchart}
\end{figure}

\section{Sistema de colas}

Como se vio previamente, \textit{Pizarra} tiene un sistema de \Gls{cola}s interno. Esto se debe a varios motivos de peso, en primer lugar se quiere hacer una separación de roles entre la aplicación web con la que los usuarios interactúan y la ejecución de código fuente. \textit{Pizarra} debe estar preparado para encolar tareas en el cluster \kahan del \acrshort{dsic}, pero otra de las posibilidades es la disponibilidad de poder hacerlo de forma local para cualquier otra persona que quiera hacer uso del aplicativo. \textit{Tablón}, el software del cual nos hemos inspirado también ofrece ejecución local, pero con ciertas limitaciones, siendo una de ellas la obligación de reiniciar la aplicación cada 60 minutos, como podemos ver en su apartado de preguntas frecuentes (FAQ)\footnote{Tablón FAQ: \url{http://frontendv.infor.uva.es/faq}}

\say{El servidor tablón está configurado para reiniciarse cada cierto tiempo. De está forma se eliminan trabajos erróneos y se eliminan las peticiones http no completadas. El tiempo que resta hasta el próximo reinicio se muestra en la página principal.}

Además, una ejecución local desde el mismo aplicativo obliga a brindarle de recursos necesarios ya sean procesadores y memoria; Esto no es muy eficiente ya que las aplicaciones en Python, y especialmente en \textit{Flask} consumen muy pocos recursos. Por eso mismo, nuestra aplicación se puede ejecutar en dos modos diferentes:

\begin{itemize}
	\item Modo \textit{Pizarra}: aplicación web con la que interactúan los usuarios
	\item Modo \textit{Worker}: un proceso que se encarga de revisar en las colas disponibles si hay \textit{Tasks} a procesar
\end{itemize}

Otro beneficio que brinda esta separación de roles es que se pueden ejecutar un número indefinido de \foreignlanguage{english}{Workers}, donde cada uno puede tener diferentes colas configuradas y unos recursos disponibles exclusivos para cada uno de ellos. La definición de  \foreignlanguage{english}{Worker} y \Gls{cola} que utilizamos están definidos en la librería RQ (Redis Queue) que permite procesar ``trabajos`` de forma asíncrona usando como fuente de datos un servicio de \textit{Redis}

Este proceso se puede ver resumido en la siguiente figura.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.90\textwidth]{img/queues}
	\caption[Proceso que sigue un Envío en la Cola interna]{Proceso que sigue un Envío en la Cola interna}
	\label{figura:queues}
\end{figure}


\chapter{Desarrollo de la solución}


Ya escogido el lenguaje de programación, el próximo paso es analizar las posibilidades para la aplicación web en sí que será el punto de acceso a los usuarios. Debido a experiencia previa en otra asignatura de la carrera universitaria he decido optar por \textit{Flask}\footnote{Sitio web Flask: \url{https://flask.palletsprojects.com/en/1.1.x/}}, un micro-framework de Python con gran acogida por la comunidad que incluye un sistema de plantillas para la generación de páginas web llamado \text{Jinja}. 

La usabilidad es uno de los aspectos más importantes de una aplicación web y en este caso no se puede dejar de lado. Un usuario de \textit{Pizarra} esperará una interfaz intuitiva y fácil de utilizar que le facilite el proceso de envío de soluciones a los problemas propuestos; No queremos que la aplicación se interponga entre el proceso de aprendizaje y la satisfacción de participar y obtener logros. Una gran cantidad de aplicaciones utilizan las mismas librerías para maquetar los sitios web, entre estas librerías la más importante es \textit{Bootstrap}\footnote{Sitio web Bootstrap: \url{https://getbootstrap.com/}}, y además, a partir de estas librerías existen Dashboards o Paneles de Control de código abierto para utilizar como punto de partida en nuevas aplicaciones.

Después de varias búsquedas y pruebas se ha optado por \textit{AdminLTE}\footnote{Sitio web AdminLTE: \url{https://adminlte.io/}} dada su variedad de plantillas disponibles, uso de otras librerías con amplia documentación y un aspecto visual amigable y moderno.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.95\textwidth]{img/admin-lte}
	\caption[AdminLTE: plantilla de Panel de Control ]{AdminLTE: plantilla de Panel de Control }
	\label{figura:admin-lte}
\end{figure}


\section{Entregables}

Sprints ¿?

\chapter{Implantación}

Pizarra es una herramienta que necesita de otros aplicativos para su funcionamiento. Por un lado una \textit{BD} para la persistencia de datos, Redis para el sistema de colas interno de envío de tareas, un \acrshort{nfs} para compartir recursos y Nginx para actuar como servidor web y redirigir las peticiones. En el pasado la implantación hubiera requerido la intervención del equipo de Administración de Sistemas que se encargue de instalar el \textit{SO} de cada máquina, crear usuarios, asignar permisos, abrir puertos y otro sinfín de tareas.

Para evitar todos estos pasos y acelerar la implantación el proyecto incluye la posibilidad de que todos los elementos de la arquitectura se desplieguen en \Gls{contenedor}es. Estos \Gls{contenedor}es están creados con la tecnología Docker y son paquetes que incluyen todo lo necesario, sean librerías y herramientas del sistema para que el software se ejecute.

Docker funciona de forma similar a una maquina virtual, con algunas ventajas como la asignación de recursos de forma dinámica, espacio en disco reducido ya que podemos evitar la instalación de un \acrshort{so} en los contenedores y la portabilidad.


\begin{figure}[ht]
	\centering
	\includegraphics[width=0.65\textwidth]{img/container-vs-vm}
	\caption[Diferencias entre contenedor Docker y máquina virtual]{Diferencias entre contenedor y máquina virtual}
	\label{figura:container-vs-vm}
\end{figure}

\section{Docker y Kubernetes}

Para nuestro entorno de desarrollo local utilizamos contenedores públicos como el de Postgres que con un fichero de configuración nos permite tener el servicio ejecutándose en cuestión de minutos.

A continuación, un extracto del fichero \textbf{docker-compose.yaml} del repositorio\footnote{Docker yaml: \url{https://github.com/nimar3/pizarra/blob/master/docker-compose.yml}} con una breve explicación de los parámetros.

\begin{lstlisting}[language=yaml]
version: "3.1"
services:
  postgres:
    image: postgres: 9.6-alpine
    container_name: postgres
    volumes:
      - /data/pizarra/postgres:/var/lib/postgresql/data
    ports:
      - 5432: 5432
    environment:
      - POSTGRES_USER=pizarra
      - POSTGRES_PASSWORD=pizarra
    restart: unless-stopped
\end{lstlisting}

\begin{itemize}
	\item \textbf{version}: versión de la API de Docker que utilizaremos.
	\item \textbf{services}: listado de servicios que desplegaremos.
	\item \textbf{image}: contenedor que utilizaremos, en este caso el oficial de postgres\footnote{Postgres Official Docker Image: \url{https://hub.docker.com/_/postgres}} sobre Linux Alpine.
	\item \textbf{container\_name}: nombre con el que comenzará el contenedor que se ejecute.
	\item \textbf{volumes}: mapeo de directorios de nuesto entorno de desarrollo local al contenedor, esto se hace para evitar perder la información de la \textit{BD} al ser los contenedores \foreignlanguage{english}{stateless}.
    \item \textbf{ports}: mapeo de puertos del \textit{SO} a los contenedores, esto permite acceder al servicio de Postgres por un puerto local.
	\item \textbf{environment}: variables de entorno del \textit{SO}, en nuestro caso definimos un usuario y contraseña para acceder a la \textit{BD}
	\item \textbf{restart}: con el parámetro \foreignlanguage{english}{unless-stopped} nuestro contenedor se reiniciará de forma automática en caso de errores a menos que se envíe un mensaje de finalización de ejecución.
\end{itemize}

Con los parámetros previos y siguiendo la documentación de variables de entorno disponibles, al iniciarse el contenedor se crearán los \foreignlanguage{english}{schemas} y directorios necesarios en caso de que no existan y un usuario con privilegios con el nombre y contraseña proporcionados.

Para un entorno de desarrollo local y/o de pruebas Docker puede ser una herramienta que cumpla con nuestras necesidades, pero para un entorno de producción es necesario contar con un servicio que realice la implantación de forma automatizada,que sea eficiente en el manejo de recursos y resilente en caso de problemas. Para ésta tarea utilizaremos Kubernetes, un \textit{orquestador} de contenedores que permite auto escalado de aplicaciones, automatización de despliegues y configuración de forma declarativa.

Debido a una limitación de las máquinas donde está alojado \kahan no es posible la instalación del servicio de Kubernetes y se ha optado por un despliegue de Pizarra en la nube.

\section{Despliegue en la Nube con Kubernetes}

Existen varios proveedores de \textit{K8s} en Internet pudiendo consultar el listado de todos los partners en el sitio oficial\footnote{Kubernetes - Partners: \url{https://kubernetes.io/es/partners}}. Siendo los más importantes Google Cloud Engine, Amazon AWS y Microsoft Azure se ha escogido por desplegar la aplicación en \textit{GCE} ya que dispone de buena documentación y además \textdollar 300 de crédito promocional que són más que suficientes para tener el aplicativo corriendo durante meses.

\subsection{Pasos de un despliegue en GCE}

Debemos crearnos una cuenta en Google o utilizar una existente que nunca ha activado \textit{GCE} de forma previa ya que el crédito promocional de bienvenida tiene una caducidad de 12 meses desde la activación.

Con nuestra cuenta accedemos a la Consola Web de \acrshort{gce} y creamos nuestro proyecto, en este caso lo llamaremos Pizarra. Nuestro aplicativo utiliza Kubernetes Engine y el Container Registry que son visibles desde el menú lateral, entraremos a cada uno de ellos para habilitar su \acrshort{api}.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.55\textwidth]{img/gce-new-project}
	\caption[nuevo proyecto en GCE]{Creación de un nuevo proyecto en Google Cloud Engine.}
	\label{figura:gce-new-project}
\end{figure}

Una vez creado el proyecto y habilitadas las \acrshort{api}'s hay que descargar\footnote{Cómo instalar el SDK de Google Cloud: \url{https://cloud.google.com/sdk/install?hl=es-419}} e inicializar\footnote{Cómo inicializar el SDK de Cloud:  \url{https://cloud.google.com/sdk/docs/initializing?hl=es-419}} Google Cloud SDK para hacer uso de la consola de forma local. 

Todos los pasos descritos a continuación se ejecutan de forma automática con un script\footnote{Script Despliegue \acrshort{gce}: \url{https://github.com/nimar3/pizarra/blob/master/gce/commands.sh}} incluido en el repositorio de código. Lo único que se necesita de forma previa es la configuración de algunos parámetros de despliegue como variables de entorno del \acrshort{so} donde se ejecuta.

Las variables de entorno necesarias son el ID del proyecto en \acrshort{gce} y las credenciales de la \acrshort{bd} que serán guardados como un secreto en Kubernetes. Podemos exportarlas antes de lanzar nuestro script ejecutando los siguientes comandos en nuestra consola.

\begin{lstlisting}[language=bash]
$ export PROJECT_ID=pizarra-id
$ export DB_USERNAME=pizarra
$ export DB_PASSWORD=pizarra
\end{lstlisting}

Éstas son las lineas que ejecuta el script, donde todos los ficheros que forman parte de cada comando se encuentran en el repositorio\footnote{Ficheros de despliegue en \acrshort{gce}: \url{https://github.com/nimar3/pizarra/tree/master/gce}}. Al ser la sintaxis similar a la previamente explicada y evitando que éste documento se extienda de sobremanera al mencionar cada ítem, invitamos al lector a revisar la documentación oficial de Kubernetes\footnote{Documentación Kubernetes: \url{https://kubernetes.io/docs}}.

\begin{enumerate}
	
	\item Seteo de proyecto y zona geográfica donde desplegaremos el aplicativo. Por cercanía geográfica se ha escogido el centro de datos de Países Bajos.
	
	\begin{lstlisting}[language=bash]
	$ gcloud config set project ${PROJECT_ID}
	$ gcloud config set compute/zone europe-west4
	\end{lstlisting}
	
	\item Credenciales para la \acrshort{bd} para ser obtenidas a posterior por los contenedores de Kubernetes
	
	\begin{lstlisting}[language=bash]
	$ kubectl create secret generic pizarra-credentials \
	--from-literal db_username=${DB_USERNAME} \
	--from-literal db_password=${DB_PASSWORD}
	\end{lstlisting}
	
	\item Subida de \Gls{contenedor}es de Nginx y Pizarra al Registro de \acrshort{gce}. Los otros \Gls{contenedor}es utilizarán imágenes públicas.
	
	\begin{lstlisting}[language=bash]	
	$ docker push eu.gcr.io/${PROJECT_ID}/pizarra
	$ docker push eu.gcr.io/${PROJECT_ID}/nginx
	\end{lstlisting}
	
	
	\item Creación de cluster en Kubernetes con 2 nodos. Una vez creado se descargan las credenciales para trabajar con él.

	\begin{lstlisting}[language=bash]	
	$ gcloud container clusters create pizarra --num-nodes=2
	$ gcloud container clusters get-credentials pizarra
	\end{lstlisting}

	\item Creación de Almacenamiento de 10 \acrshort{gib} para la persistencia de datos que será utilizado por el Sistema de archivos de red. Replicado en varias zonas ya que el almacenamiento no es parte de Kubernetes.
	
	\begin{lstlisting}[language=bash]	
	$ kubectl apply -f storage.yaml
	\end{lstlisting}
	
	\item Creación del servicio de \acrshort{nfs}
	
	\begin{lstlisting}[language=bash]	
	$ kubectl apply -f nfs.yaml
	\end{lstlisting}
	
	\item Creación del servicio de Redis para el sistema de colas local
	
	\begin{lstlisting}[language=bash]	
	$ kubectl apply -f redis.yaml
	\end{lstlisting}
	
	\item Creación del servicio de \acrlong{bd}
	
	\begin{lstlisting}[language=bash]	
	$ kubectl apply -f postgress.yaml
	\end{lstlisting}
	
	\item Despliegue de Pizarra y 1 Worker que se encargará de encolar las las \Gls{tarea}s en \kahan
	
	\begin{lstlisting}[language=bash]	
	$ kubectl apply -f pizarra.yaml
	\end{lstlisting}
	
	\item Despliegue del servicio de NGinx con una IP pública para el acceso externo de usuarios
	
	\begin{lstlisting}[language=bash]	
	$ kubectl apply -f nginx.yaml
	\end{lstlisting}
	
\end{enumerate}

Una vez completados todos los pasos se puede obtener la IP pública de Pizarra ejecutando el siguiente comando.

\begin{lstlisting}[language=bash]	
$ kubectl get services
\end{lstlisting}

También se puede obtener en la web de \acrshort{gce} sobre la pestaña Services e Ingress.

IMAGEN

Hemos completado el despliegue y ya podemos navegar a Pizarra para comenzar a interactuar con el aplicativo.

IMAGEN

\subsection{Costos asociados}

\acrshort{gce} cuenta con una herramienta\footnote{Calculadora de precios de Google: \url{https://cloud.google.com/products/calculator/}} para estimar el gasto mensual en el que podemos incurrir con la utilización de los recursos contratados. Se ha realiado una estimación con los siguientes parámetros:

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.85\textwidth]{img/google-cloud-engine-cluster-cost}
	\caption[Calculadora de precios en GCE]{Configuración de la calculadora de precios para el despliegue en Kubernetes de Pizarra.}
	\label{figura:gce-estimated-cost}
\end{figure}

\begin{itemize}
	\item  Kubernetes
	\begin{itemize}
		\item Número de nodos: 2
		\item Tipo de Instancia: n1-standard-n1 (vCPUs: 1, RAM: 3.75 GB)
		\item Centro de Datos: Países Bajos 
	    \item Uso estipulado: 24 horas al día los 7 días a la semana.
	 \end{itemize}
    \item Persistencia
	\begin{itemize}
		\item Tamaño disco: 10 GiB
		\item Centro de Datos: Países Bajos
    \end{itemize}
\end{itemize}

En resumen, el número de nodos es 2 para tener servicio en caso de que haya una caída de uno de los nodos del cluster, el centro de datos se ha escogido Países Bajos por cercanía geográfica y una instancia con los recursos mínimos necesarios para los contenedores. El disco es compartido entre la \textit{BD} y Pizarra con suficiente margen para evitar problemas de espacio.

En total llegamos a un costo estimado de \texteuro 49.00 mensuales. Como dato adicional, se puede variar de Centro de Datos y otros parámetros como el uso estipulado para reducir los costos aún más. Podemos guardar la estimación o enviárnosla por correo electrónico.


\begin{figure}[ht]
	\centering
	\includegraphics[width=0.55\textwidth]{img/google-cloud-engine-estimated-cost}
	\caption[Estimación de costos en GCE]{Ejemplo de correo de GCE con una estimación de los costos asociados por mes para la implantación.}
	\label{figura:gce-estimated-cost-email}
\end{figure}

\chapter{Mantenimiento}

El desarrollo de software es un proceso evolutivo y requiere de un mantenimiento continuo para asegurar el correcto funcionamiento, como así también la posibilidad de añadir mejoras y nuevas funcionalidades. Para poder asegurar este proceso tienen que cumplirse ciertas pautas.

Acceso al código fuente, en este caso disponible en un repositorio de código abierto en Internet, una guía de como configurar un entorno de desarrollo local y el proceso a seguir para mantener un estándar de calidad en el código fuente. Los siguientes apartados abordan todas estas pautas y así ayudar con este proceso.

\section{Entorno local de desarrollo}

Para configurar un entorno de desarrollo local se debe cumplir  los siguientes requisitos.

\begin{itemize}
	\item  Tener instalado Python3\footnote{Descarga oficial de Python: \url{https://www.python.org/downloads/}} y Docker\footnote{Descarga oficial de Docker: \url{https://docs.docker.com/get-docker/}} en nuestra máquina
	\item Clonado el repositorio de Pizarra
	\begin{enumerate}
		\item Creación de directorio
		\begin{lstlisting}[language=bash]
		$ mkdir pizarra
		$ cd pizarra/
		\end{lstlisting}
		\item Inicialización de un repositorio nuevo y la dirección remota
		\begin{lstlisting}[language=bash]
		$ git init .
		Initialized empty Git repository in /Users/nmartini/pizarra/.git/
		$ git remote add upstream git@github.com:nimar3/pizarra.git
		\end{lstlisting}
		\item Descarga del código fuente
		\begin{lstlisting}[language=bash]
		$ git fetch upstream
		remote: Enumerating objects: 589, done.
		remote: Counting objects: 100% (589/589), done.
		remote: Compressing objects: 100% (364/364), done.
		remote: Total 6891 (delta 396), reused 393 (delta 221), pack-reused 6302
		Receiving objects: 100% (6891/6891), 19.14 MiB | 675.00 KiB/s, done.
		Resolving deltas: 100% (1748/1748), done.
		\end{lstlisting}
		\item \foreignlanguage{english}{checkout} a la rama de desarrollo
		\begin{lstlisting}[language=bash]
		$ git checkout master
		Checking out files: 100% (4858/4858), done.
		Branch 'master' set up to track remote branch 'master' from 'upstream'.
		Already on 'master'
		\end{lstlisting}
	\end{enumerate}
	\item Creación de un entorno virtual e instalación de todos los \Gls{paquete}s de Python necesarios
	\begin{lstlisting}[language=bash]
	$ python3 -m venv env
	$ source env/bin/activate   
	(env) $ pip3 install -r requirements_dev.txt
	\end{lstlisting}
\end{itemize}

Si hemos realizado cambios en el código fuente se debe ejecutar el siguiente comando para generar una nueva versión de nuestro \Gls{contenedor} de Docker de Pizarra

\begin{lstlisting}[language=bash]
$ docker build -t pizarra .
\end{lstlisting}

Por último, para ejecutar Pizarra con todos los componentes introducimos el siguiente comando en la raíz del repositorio. Todos los componentes deben mostrar que se han creado correctamente con el mensaje \textit{done}

\begin{lstlisting}[language=bash]
(env) $ docker-compose up
Creating network "pizarra_default" with the default driver
Creating redis    ... done
Creating postgres ... done
Creating pizarra  ... done
Creating worker   ... done
Creating nginx    ... done
\end{lstlisting}

Se puede acceder a la aplicación web con mediante la URL https://127.0.0.1/ y se redirigirá automáticamente al inicio de sesión.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.40\textwidth]{img/docker-compose-pizarra}
	\caption[Inicio de sesión en Pizarra]{Inicio de sesión en Pizarra.}
	\label{figura:docker-compose-pizarra}
\end{figure}

En algunos casos sólo es necesario la ejecución del aplicativo web con una base de datos local en SQLite. Para estos casos se puede utilizar el siguiente comando y acceder mediante la  URL http://127.0.0.1:5000/ (el puerto por defecto de \textit{Flask} es el 5000).

\begin{lstlisting}[language=bash]
(env) $ python3 run.py 
* Serving Flask app "app" (lazy loading)
* Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
\end{lstlisting}



\section{Depuración de errores}

Como todo software, Pizarra no estará exento de errores o \foreignlanguage{english}{bugs} que no se han identificado en la etapa de desarrollo y como muchos otros lenguajes Python ofrece la ejecución de código en modo Debug, lo que nos permite poner puntos de ruptura y hacer una ejecución \textit{paso a paso} del código para identificar el problema.

En el entorno de desarrollo local, el modo Debug siempre está habilitado. Si queremos habilitarlo cuando ejecutamos el aplicativo en modo \textit{Production} debemos especificarlo explícitamente en las variables de entorno del \acrshort{so}, en este caso y para más información revisar el Apéndice A: Configuración del Sistema.

\section{Calidad de código}

Para una mejor lectura del código fuente se ha utilizado el \Gls{paquete} \textit{flake8}\footnote{Sitio Web de Flake8: \url{https://flake8.pycqa.org/en/latest/}} que nos obliga a seguir las guías de estilo oficiales de Python.

En el directorio raíz del repositorio de código ejecutamos el siguiente comando y podemos ver un listado de errores a corregir.

\begin{lstlisting}[language=bash]
$ flake8 app/
app/__init__.py:8:1: F401 'logging.DEBUG' imported but unused
app/__init__.py:71:5: E722 do not use bare 'except'
app/home/routes.py:59:101: E501 line too long (106 > 100 characters)
app/home/routes.py:210:5: E722 do not use bare 'except'
app/home/routes.py:216:101: E501 line too long (108 > 100 characters)
app/admin/forms.py:32:28: N805 first argument of a method should be named 'self'
\end{lstlisting}

La configuración de \textit{flake8} se encuentra en el fichero \textbf{setup.tfg} en la raíz del repositorio.

\begin{lstlisting}[language=bash]
[flake8]
max-line-length=100
ignore=E402,E266
exclude=./migrations
\end{lstlisting}

Otro punto importante es la cobertura del código fuente. Aunque el repositorio incluye las librerías de \textit{coveralls} y \textit{pytest} por cuestiones de tiempo no se han escrito tests unitarios y se ha dejado como una mejora futura.

\chapter{Extensibilidad}

Uno de los puntos más importantes es permitir la colaboración y que Pizarra pueda utilizar otros sistemas de tareas que no sean una \Gls{cola} local o la de un cluster como \kahan(TORQUE\footnote{Sitio web de TORQUE: \url{https://adaptivecomputing.com/cherry-services/torque-resource-manager/}}) así como también que pueda ser localizado en diferentes idiomas.

\section{Otros sistemas de Gestión de Tareas}

La ejecución de una tarea es diferente en cada \Gls{cola} y para esto se ha implementado un autómata que va cambiando de estados en cada ejecución hasta finalizarla. Esto permite que cada nuevo tipo de \Gls{cola} tenga su propia definición, sea flexible y compatible con el funcionamiento del aplicativo.

La definición de estas \Gls{cola}s se encuentra en \textbf{models\_tasks.py}\footnote{Definición de Colas: \url{https://github.com/nimar3/pizarra/blob/master/app/base/models_tasks.py}} siendo \textit{Task} el objeto a extender para las nuevas implementaciones.

\begin{lstlisting}[language=python]
class Task:

	def __init__(self, user_request):
	self.user_request = user_request
	self.output = ""
	self.binary_file_location = ""
	self.return_code = 0
	self.run_time = 0.0
	self.points_earned = 0
	# automata
	self.task_process = {}
\end{lstlisting}

El autómata cuenta con las siguientes transiciones

\begin{lstlisting}[language=python]
class StepResult(enum.Enum):
	START = 0
	OK = 1
	NOK = 2
	WAIT = 3
	END = 4
\end{lstlisting}

Para el sistema de \Gls{cola}s de \kahan tenemos el siguiente extracto. Donde creamos la nueva clase \textit{KahanTask} que extiende de \textit{LocalTask} y hereda todos sus atributos y métodos.

\begin{lstlisting}[language=python]
class KahanTask(LocalTask):

	def __init__(self, user_request):
	super().__init__(user_request)
	self.task_process = {
		RequestStatus.CREATED: {
		'f': self.start,
		'steps': {
			StepResult.OK: RequestStatus.VERIFYING,
		}
	},
	RequestStatus.VERIFYING: {
		'f': self.verify,
		'steps': {
			StepResult.OK: RequestStatus.COMPILING,
			StepResult.NOK: RequestStatus.ERROR
		}
	},
	RequestStatus.COMPILING: {
		'f': self.compile,
		'steps': {
			StepResult.OK: RequestStatus.DEPLOYING,
			StepResult.NOK: RequestStatus.ERROR
		}
	},
...
\end{lstlisting}

En la definición del \textit{task\_process} tenemos un diccionario con los diferentes estados que puede encontrarse el autómata, la función a ejecutar \textit{f} y para cada ejecución el diccionario \textit{steps} con las transiciones.

\section{Localización}

Pizarra utiliza el \Gls{paquete} \textit{Babel}\footnote{Paquete \textit{Babel}: \url{http://babel.pocoo.org/en/latest/}} para ofrecer los diferentes idiomas disponibles a los usuarios. A continuación se muestra el \textit{paso a paso} para añadir un nuevo Idioma.

La configuración de \textit{Babel} se encuentra en el fichero \textbf{babel.cfg}\footnote{Configuración de \textit{Babel}: \url{https://github.com/nimar3/pizarra/blob/master/babel.cfg}} en la que se define los ficheros a escanear y extraer texto a traducir.

\begin{lstlisting}[language=python]
[python: app/**.py]
[jinja2: app/**/templates/**.html]
extensions=jinja2.ext.autoescape,jinja2.ext.with_
\end{lstlisting}

Con el siguiente comando se extrae el texto. En la consola se visualiza como se van escaneando todos los ficheros y el resultado lo tendremos disponible en el fichero \mbox{\textbf{messages.pot}} 

\begin{lstlisting}[language=bash]
(venv) $ pybabel extract -F babel.cfg -k _l -o messages.pot .
...
extracting messages from app/home/templates/macros/summaries.html (extensions="jinja2.ext.autoescape,jinja2.ext.with_")
extracting messages from app/home/templates/macros/teams.html (extensions="jinja2.ext.autoescape,jinja2.ext.with_")
writing PO template file to messages.pot
\end{lstlisting}

Una vez extraído el texto hay que generar el fichero de localización para el idioma que vayamos a traducir. Las localizaciones se encuentran en el directorio \textit{/app/translations}. 

\begin{lstlisting}[language=bash]
(env) $ pybabel init -i messages.pot -d app/translations -l es
creating catalog app/translations/es/LC_MESSAGES/messages.po based on messages.pot
\end{lstlisting}

El siguiente paso es comenzar a añadir las traducciones en las líneas identificadas con \textit{msgstr}

\begin{lstlisting}[language=bash]
$  cat app/translations/es/LC_MESSAGES/messages.po
...
#: app/account/routes.py:34
msgid "New Access Token has been generated!"
msgstr "Nuevo Token de acceso ha sido generado!"

#: app/account/routes.py:54
msgid "You joined Team {}"
msgstr "Te has unido al equipo {}"

#: app/account/routes.py:56
msgid "You are unable to join team {} because is full"
msgstr ""
...
\end{lstlisting}

Se deben compilar las traducciones.

\begin{lstlisting}[language=bash]
(env) $ pybabel compile -d app/translations
compiling catalog app/translations/es/LC_MESSAGES/messages.po to app/translations/es/LC_MESSAGES/messages.mo
\end{lstlisting}

Y se añade a la configuración de Pizarra el nuevo idioma disponible.

\begin{code}{config.py}
	...
	SUPPORTED_LANGUAGES = {'es': 'Spanish', 'en': 'English'}
	...
\end{code}

En el menú se visualizará el nuevo idioma disponible.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.50\textwidth]{img/pizarra-new-language}
	\caption[Selector de Idiomas en Pizarra]{Selector de Idiomas en Pizarra.}
	\label{figura:pizarra-new-language}
\end{figure}




\chapter{Conclusiones}

... \par

\section{Relación del trabajo desarrollado con los estudios cursados}

?

\chapter{Trabajos futuros}

?

\begin{thebibliography}{10}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MODEL D'ARTICLE                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibitem{light}
   Jennifer~S. Light.
   \newblock When computers were women.
   \newblock \textit{Technology and Culture}, 40:3:455--483, juliol, 1999.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MODEL DE LLIBRE                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibitem{ifrah}
   Georges Ifrah.
   \newblock \textit{Historia universal de las cifras}.
   \newblock Espasa Calpe, S.A., Madrid, sisena edició, 2008.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MODEL D'URL                                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibitem{WAR}
   Comunicat de premsa del Departament de la Guerra, 
   emés el 16 de febrer de 1946. 
   \newblock Consultat a 
   \url{http://americanhistory.si.edu/comphist/pr1.pdf}.

\end{thebibliography}
\cleardoublepage

\APPENDIX

\chapter{Configuración del sistema}

Para un correcto funcionamiento de Pizarra el sistema debe inicializarse siguiendo los pasos descritos a continuación. Aunque se dispone de un script que realiza el despliegue de forma automatizada hay algunos pasos que requieren de intervención manual.

\section{Inicialización}

Antes de comenzar con la inicialización del sistema, debemos exportar las variables de entorno del \acrshort{so} que utiliza el script. Abrimos una consola y ejecutamos los siguientes comandos, donde \textit{pizarra-id} es el ID de proyecto en \acrfull{gce}.

\begin{lstlisting}[language=bash]
$ export PROJECT_ID=pizarra-id
$ export DB_USERNAME=pizarra
$ export DB_PASSWORD=pizarra
\end{lstlisting}

Si quisiéramos cambiar algún parámetro por defecto de Pizarra, debemos modificar el fichero \textbf{pizarra.yaml}\footnote{Fichero YAML de Pizarra: \url{https://github.com/nimar3/pizarra/blob/master/gce/pizarra.yaml}} añadiendo los nuevos parámetros. En el siguiente extracto se han cambiado los puntos de penalización al obtener un \textit{KO} y \textit{TIMEWALL} en el envío de una \Gls{tarea} y la carga de datos de ejemplo.

\begin{lstlisting}[language=yaml]
...
spec:
  containers:
    - image: eu.gcr.io/pizarra-279100/pizarra
      name: pizarra
      env:
        - name: TIMEWALL_PENALTY
          value: "-20"
        - name: "KO_PENALTY
          value: "-30"
        - name: "IMPORT_SAMPLE_DATA"
          value: "True"
...          
\end{lstlisting}

A continuación se ejecuta el script.

\begin{lstlisting}[language=bash]
$ sh commands.sh
\end{lstlisting}

Al terminar la ejecución deberíamos tener Pizarra con todos los componentes desplegados. Podemos obtener el estado de los contenedores y servicios con los siguientes comandos.

\begin{lstlisting}[language=bash]
$ kubectl get pods
$ kubectl get services
\end{lstlisting}

\section{Parámetros}

Al iniciar un \Gls{contenedor} utilizamos variables de entorno del \acrshort{so} para configurar su funcionamiento. El \Gls{contenedor} de Pizarra soporta estas variables para dar diferentes posibilidades en cómo queremos que se comporte el aplicativo. 

Los mencionados a continuación con su descripción y opciones son los más relevantes en un despliegue. También se listan otros parámetros adicionales como referencia. Todos estos pueden ser consultados en el fichero de configuración\footnote{Fichero de Configuración: \url{https://github.com/nimar3/pizarra/blob/master/config.py}}.

\begin{itemize}
	\item \textbf{APP\_MODE}
	\begin{itemize}
		\item Descripción: ejecución del aplicativo web o un worker
		\item Opciones
		\begin{itemize}
			\item Pizarra: aplicativo web
			\item Worker: worker
		\end{itemize}
		\item Valor por defecto: \textit{Pizarra}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{CONFIG\_MODE}
	\begin{itemize}
		\item Descripción: modo en el cual queremos que se ejecute Pizarra
		\item Opciones
		\begin{itemize}
			\item Debug: modo Debug habilitado y \acrfull{bd} SQLite
			\item Production: modo Debug deshabilitado y \acrfull{bd} Postgres
		\end{itemize}
		\item Valor por defecto: \textit{Debug}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{REMOTE\_HOST}
	\begin{itemize}
		\item Descripción: hostname o IP del sistema externo a conectarnos para las colas de \kahan
		\item Valor por defecto: \textit{kahan.dsic.upv.es}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{REMOTE\_USER}
	\begin{itemize}
		\item Descripción: usuario con el que nos conectaremos por \acrshort{ssh} y \acrshort{scp} a \kahan
		\item Valor por defecto: \textit{pizarra}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{REMOTE\_PATH}
	\begin{itemize}
		\item Descripción: directorio remoto donde se copiarán los ficheros de cada ejecución en \kahan
		\item Valor por defecto: \textit{/pizarra}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{SSH\_FILE\_PATH}
	\begin{itemize}
		\item Descripción: ubicación de la clave privada para conectarnos por \acrshort{ssh} y \acrshort{scp} a \kahan
		\item Valor por defecto: \textit{app/data/keys/id\_rsa}
	\end{itemize}
\end{itemize}


\begin{itemize}
	\item \textbf{LOG\_LEVEL}
	\begin{itemize}
		\item Descripción: establece el nivel de mensajes que deben mostrarse al ejecutarse el aplicativo
		\item Opciones
		\begin{itemize}
			\item CRITICAL
			\item ERROR
			\item WARNING
			\item INFO
			\item DEBUG
		\end{itemize}
		\item Valor por defecto: \textit{INFO}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{SECRET\_KEY}
	\begin{itemize}
		\item Descripción: clave secreta con la que se encriptarán las contraseñas, no se puede cambiar una vez desplegada la aplicación y por seguridad nunca debe utilizarse el valor por defecto
		\item Valor por defecto: \textit{pizarra-app}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{IMPORT\_SAMPLE\_DATA}
	\begin{itemize}
		\item Descripción: borrado de información de la \acrlong{bd} e importación de data de ejemplo.
		\item Valor por defecto: \textit{False}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{TIME\_BETWEEN\_REQUESTS}
	\begin{itemize}
		\item Descripción: tiempo mínimo en segundos que debe esperar un \Gls{alumno} entre cada envío de \Gls{tarea}s
		\item Valor por defecto: \textit{60}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{TEAM\_MAX\_SIZE}
	\begin{itemize}
		\item Descripción: tamaño máximo de \Gls{alumno}s que puede tener un \Gls{equipo}
		\item Valor por defecto: \textit{3}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{REGISTRATION\_ENABLED}
	\begin{itemize}
		\item Descripción: habilita el registro de usuarios en el aplicativo
		\item Valor por defecto: \textit{False}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{TIMEWALL\_PENALTY}
	\begin{itemize}
		\item Descripción: puntos de penalización al obtener un resultado de \textit{TIMEWALL} en un envío de \Gls{tarea}
		\item Valor por defecto: \textit{-10}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{KO\_PENALTY}
	\begin{itemize}
		\item Descripción: puntos de penalización al obtener un resultado de \textit{KO} en un envío de \Gls{tarea}
		\item Valor por defecto: \textit{-15}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{DEBUG}
	\begin{itemize}
		\item Descripción: inicia el aplicativo en modo Debug, útil para identificar errores.
		\item Valor por defecto: \textit{False}
	\end{itemize}
\end{itemize}

\subsection*{Parámetros adicionales}

\begin{itemize}
	\item SQLALCHEM\_DATABASE\_URI
	\item SQLALCHEMY\_TRACK\_MODIFICATIONS
	\item JSONIFY\_PRETTYPRINT\_REGULAR
	\item SUPPORTED\_LANGUAGES
	\item BABEL\_DEFAULT\_LOCALE
	\item BABEL\_DEFAULT\_TIMEZONE
	\item UPLOAD\_FOLDER
	\item FILE\_ALLOWED\_EXTENSIONS
	\item MAX\_CONTENT\_LENGTH
	\item TIMEWALL
	\item FORBIDDEN\_CODE
	\item RQ\_DASHBOARD\_REDIS\_URL
	\item QUEUES
	\item COMPILER
\end{itemize}


\chapter{Licencia}

Como este es un proyecto de código abierto, se ha escogido la Licencia MIT\footnote{Licencia MIT: \url{https://opensource.org/licenses/MIT}} ya que es una de las más permisivas para fomentar la reutilización y colaboración. Este tipo de licencia permite el libre uso de forma privada o comercial, la modificación y distribución del código sin ningún tipo de garantía donde solo se pide que se mantengan las menciones a la licencia y derechos de autor.


\glsaddall
\printglossary[title=Acrónimos,type=\acronymtype]

\glsaddall
\printglossary[title=Términos,toctitle=Terms and abbreviations]

\end{document}
