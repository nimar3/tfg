\documentclass[11pt,spanish,listoffigures,listoftables]{tfgetsinf}

\usepackage[utf8]{inputenc} 
\usepackage{textcomp}

% custom bulletpoint for tables
\usepackage{enumitem}
\newlist{tabitem}{itemize}{1}
\setlist[tabitem]{wide=0pt, nosep, leftmargin= * ,label=\textbullet,after=\vspace{-\baselineskip},before=\vspace{-0.6\baselineskip}}
%

% custom dedication
\newenvironment{dedication}
{%\clearpage           % we want a new page          %% I commented this
	\thispagestyle{empty}% no header and footer
	\itshape             % the text is in italics
}
{\par % end the paragraph
	\vspace{\stretch{3}} % space at bottom is three times that at the top
	\clearpage           % finish off the page
}

% link colors in table black
\hypersetup{%
	colorlinks = true,
	linkcolor  = black
}

% YAML definition  - START

\newcommand\YAMLcolonstyle{\color{red}\mdseries}
\newcommand\YAMLkeystyle{\color{black}\bfseries}
\newcommand\YAMLvaluestyle{\color{blue}\mdseries}

\makeatletter

% here is a macro expanding to the name of the language
% (handy if you decide to change it further down the road)
\newcommand\language@yaml{yaml}

\expandafter\expandafter\expandafter\lstdefinelanguage
\expandafter{\language@yaml}
{
	keywords={true,false,null,y,n},
	keywordstyle=\color{darkgray}\bfseries,
	basicstyle=\YAMLkeystyle,                                 % assuming a key comes first
	sensitive=false,
	comment=[l]{\#},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{purple}\ttfamily,
	stringstyle=\YAMLvaluestyle\ttfamily,
	moredelim=[l][\color{orange}]{\&},
	moredelim=[l][\color{magenta}]{*},
	moredelim=**[il][\YAMLcolonstyle{:}\YAMLvaluestyle]{:},   % switch to value style at :
	morestring=[b]',
	morestring=[b]",
	literate =    {---}{{\ProcessThreeDashes}}3
	{>}{{\textcolor{red}\textgreater}}1     
	{|}{{\textcolor{red}\textbar}}1 
	{\ -\ }{{\mdseries\ -\ }}3,
}

% switch to key style at EOL
\lst@AddToHook{EveryLine}{\ifx\lst@language\language@yaml\YAMLkeystyle\fi}
\makeatother

\newcommand\ProcessThreeDashes{\llap{\color{cyan}\mdseries-{-}-}}

% YAML definition - END


\lstnewenvironment{code}[2][]{%
	\lstset{%
		backgroundcolor=\color{gray!10},  
		basicstyle=\ttfamily,
		numbers=none, 
		breakatwhitespace=false,      
		breaklines=true,
		title   = #2,
		#1,
	}%
}{}

\hypersetup{citecolor=black}

\usepackage{listings}
\lstdefinestyle{ascii-tree}{
	literate={├}{|}1 {─}{--}1 {└}{+}1 ,
	backgroundcolor=\color{gray!10},  
	basicstyle=\ttfamily,
	numbers=none
}
\usepackage{dirtytalk}
\usepackage[acronym]{glossaries}
\usepackage{placeins}
\usepackage{pgf, tikz}
\usetikzlibrary{arrows, automata}

\makeglossaries

\newglossaryentry{tarea}{name=Tarea,description={Problema a resolver asignado a un estudiante o equipo}}
\newglossaryentry{insignia}{name=Insignia,description={Trofeo o Marcador que se obtiene al realizar cierta acción en la aplicación}}
\newglossaryentry{ede}{name=Equipo de Estudiantes,description={Grupo de uno o más estudiantes formado para resolver Tareas de forma conjunta}}
\newglossaryentry{gde}{name=Grupo de Estudiantes,description={Clase a la que pertenece el estudiante para el año lectivo}}
\newglossaryentry{edp}{name=Entorno de producción,description={lugar donde se ejecuta el aplicativo para los usuarios finales}}
\newglossaryentry{contenedor}{name={Contenedor},description={imagen ejecutable ligera y portátil que contiene el software y todas sus dependencias}}
\newglossaryentry{administrador}{name={Administrador},description={Usuario con un rol que le permite administrar el sistema, normálmente será el profesor de un curso académico}}
\newglossaryentry{alumno}{name={Alumno},description={Estudiante que forma parte de un curso académico}}
\newglossaryentry{equipo}{name={Equipo},description={Grupo de estudiantes que pertenecen a una misma clase en un grupo académico}}
\newglossaryentry{grupo}{name={Grupo},description={Agrupación de alumnos que pertenecen a un grupo académico}}
\newglossaryentry{cola}{name={Cola},description={Estructura de datos que sigue una filosofía FIFO}}
\newglossaryentry{clase}{name={Clase},description={Plantilla para la creación de objetos de datos según un modelo predeterminado}}
\newglossaryentry{paquete}{name={Paquete},description={Carpeta que contiene varios módulos de Python}}
\newglossaryentry{envio}{name={Envío},description={Petición web que incluye el código fuente a compilar y ejecutar como propuesta de solución a una Tarea}}

\newacronym{dsic}{DSIC}{Departamento de Sistemas Informáticos y Computación}
\newacronym{upv}{UPV}{Universitat Politècnica de València}
\newacronym{etsinf}{ETSINF}{Escola Tècnica Superior d'Enginyeria Informàtica}
\newacronym{cpa}{CPA}{Computación Paralela}
\newacronym{lpp}{LPP}{Lenguajes y Entornos de la Programación Paralela}
\newacronym{tfg}{TFG}{Trabajo Final de Grado}
\newacronym{rf}{RF}{Requisito funcional}
\newacronym{rnf}{RNF}{Requisito no funcional}
\newacronym{gce}{GCE}{Google Cloud Engine}
\newacronym{bd}{BD}{Base de datos}
\newacronym{so}{SO}{Sistema operativo}
\newacronym{k8s}{K8s}{Kubernetes}
\newacronym{ram}{RAM}{Memoria de acceso aleatorio}
\newacronym{vcpus}{vCPUs}{Unidades centrales de procesamiento virtuales}
\newacronym{api}{API}{Interfaz de programación de aplicaciones}
\newacronym{gib}{GiB}{Gibibyte}
\newacronym{nfs}{NFS}{Sistema de archivos de red}
\newacronym{ssh}{SSH}{Secure Shell}
\newacronym{scp}{SCP}{Secure Copy}
\newacronym{fifo}{FIFO}{Primero en entrar, primero en salir}
\newacronym{mvc}{MVC}{Modelo Vista Controlador}
\newacronym{gii}{GII}{Grado de Ingeniería Informática}
\newacronym{cpu}{CPU}{Unidad central de procesamiento}
\newacronym{wsgi}{WSGI}{Web Server Gateway Interface}
\newacronym{http}{HTTP}{Hypertext Transfer Protocol}
\newacronym{json}{JSON}{JavaScript Object Notation}
\newacronym{orm}{ORM}{Object-Relational mapping}
\newacronym{ide}{IDE}{Entorno de desarrollo integrado}
\newacronym{uml}{UML}{Lenguaje Unificado de Modelado}
\newacronym{vm}{VM}{Máquina Virtual}
\newacronym{mb}{MB}{Megabytes}

\usepackage{listings}
\usepackage{wrapfig}

\title{Implementación de un sitio web para un concurso de programación paralela}
\author{Nicolás Fernando Martini}
\tutor{Pedro Alonso Jordá}
\curs{2019-2020}


\keywords{?, ?, ?, ?} 
         {programación paralela, concurso de programación, gamificación, ludificación}  
         {parallel programming, programming competition, gamification}       

\begin{document}
	

\begin{dedication}	
	
	\chapter*{Dedicatoria}
	
	...

	\chapter*{Agradecimientos}
		A mi tutor Pedro Alonso Jordá por su apoyo y la oportunidad de hacer este proyecto con la esperanza que produzca un impacto positivo en la enseñanza en los cursos venideros. \par
		A la Escola Tècnica Superior d'Enginyeria Informàtica y todos sus profesores, gracias a ellos he podido crecer personal y profesionalmente. \par
		Al Ministerio de Educación y Gobierno de España, gracias a sus ayudas he podido acceder los estudios de grado.
		
\end{dedication}

\begin{abstract}

... \par

... \par

... \par

\end{abstract}

\begin{abstract}[spanish]
	
El presente trabajo aborda la implementación de un sitio web para concursos de programación paralela, con el añadido de la gamificación o ludificación, una técnica de aprendizaje que busca recompensar al usuario y aumentar su motivación al sumar elementos y dinámicas propias de los juegos para así ofrecer una experiencia enriquecedora y positiva. \par 

Esta es una tarea compleja, por un lado llevar el proceso de envío de código a un entorno web y la interacción que tendrá con el cluster \kahan del DSIC. Y por el otro, transformar las actividades de laboratorio de las asignaturas CPA y LPP con nuevas mecánicas que produzcan al estudiante buscar mejorar sus resultados inclusive después de llegar a una resolución correcta a los ejercicios planteados. \par

Este proyecto ha sido realizado con el apoyo del DSIC de la UPV con la finalidad de complementar otras herramientas utilizadas hoy en día en la enseñanza. \par


\end{abstract}

\begin{abstract}[english]

... \par

... \par

... \par

\end{abstract}

\mainmatter

\chapter{Introducción}

En este proyecto se trabajarán dos conceptos importantes, la programación paralela y la \textit{gamificación}. \par

La programación paralela es una rama importante de la computación donde se busca partir problemas de gran magnitud en pedazos más pequeños donde cada partición es ejecutada de forma simultánea por diferentes recursos computacionales de forma coordinada. Este tipo de ejecución tiene varias ventajas como la posibilidad de obtener soluciones a problemas que no pueden ser resueltos en un tiempo razonable, que tienen un orden y complejidad mayor. La programación paralela también trae sus desventajas como una mayor complejidad al escribir los programas, evitar condiciones de carrera y la sincronización entre los recursos. \par

La gamificación es una técnica o método de aprendizaje que busca potenciar la motivación, esfuerzo e implicación utilizando elementos y estructuras propias de juegos como destacar en posiciones de clasificación, la competencia entre equipos y la obtención de premios. Todo esto para crear una experiencia positiva y dinámica que implique a los usuarios y produzca una asimilación natural de los contenidos. \par

El objetivo es crear una herramienta de software (aplicación web) que acerque estos ``dos mundos'' y crear a una experiencia que fomente la colaboración, incentive al alumnado en mejorar sus resultados y afianzar conceptos desde el marco de la competición.

Con la implementación de un sitio web para un concurso de programación paralela y el uso de la gamificación se espera lograr una mejora en la participación de los estudiantes y así llegar a transformar las actividades de laboratorio de \acrfull{lpp}, asignatura de la rama de Computación, como también la de \acrfull{cpa}, asignatura obligatoria del tercer bloque; ambas del \acrfull{gii} de la \acrfull{etsinf}. \par

\section{Motivación}

Desde el inicio de mis estudios en el \acrshort{gii} me han interesado los concursos de programación, ya sean los promovidos desde la propia \acrshort{etsinf} así como también los disponibles en plataformas online como UVa\footnote{UVa Online Judge website: \url{https://onlinejudge.org/}.}, HackerRank\footnote{HackerRank website: \url{https://www.hackerrank.com/}.}, CheckIO\footnote{CheckIO website: \url{https://checkio.org/}.} y Project Euler\footnote{Project Euler website: \url{https://projecteuler.net/}.}. Estas competiciones ayudan a promover el interés en diferentes conceptos fundamentales que debe conocer cualquier profesional de las Ciencias de la Computación, como son las estructuras de datos y la algoritmia, con el añadido de un marco lúdico con elementos de lo que llamamos previamente gamificación. \par

Normalmente los concursos o competiciones de programación sólo buscan la resolución de una serie de problemas para un conjunto finito de entradas sin importar los tiempos de ejecución o su eficiencia. Por eso al ver la publicación de la propuesta del \acrfull{tfg} donde se añade la programación paralela me ha despertado el interés ya que también se premiará la eficacia del código, esto es, obtener una solución correcta en el menor tiempo posible y además, el añadido de tener que trabajar con un elemento externo como lo es el \foreign{english}{cluster} \kahan del \acrfull{dsic}.  \par

Crear esta aplicación que podrán utilizar los alumnos en cursos venideros es mi principal motivación y forma de devolver a la Universidad las herramientas y formación recibida para lograr convertirme en un profesional de la Informática. 

\section{Objetivo}

Desde mi punto de vista no existe un único objetivo al realizar un \acrshort{tfg}, mas allá de que el principal de este sea la implementación de un sitio web para concursos de programación paralela existen otros puntos importantes a considerar; la documentación del proceso realizado, los conocimientos aplicados, lo que se ha aprendido y qué aportes puede brindar a la comunidad científica. \par 

Considero de suma importancia poner de manifiesto los siguientes objetivos secundarios: 1) el seguimiento de un proceso formal para el análisis, diseño, implantación y mantenimiento del software, siendo conceptos previamente vistos en la rama de Ingeniería de Software y esenciales en cualquier proyecto ingenieril; 2) ofrecer una herramienta \foreign{english}{open source} abierta a la colaboración, de uso libre y a disposición de otros centros de estudio; 3) explorar nuevas herramientas utilizadas actualmente en el mercado ampliando así mis capacidades como profesional de la Informática.

\section{Impacto esperado}

La creación de este producto logra una serie de mejoras con respecto a las alternativas actuales de software para competiciones de programación paralela. Como principal característica se añade la posibilidad de despliegue de la aplicación en un servicio en la nube (\foreign{english}{cloud}) y el uso de tecnologías actuales en el ámbito del desarrollo de software como lo son \textit{Docker}\footnote{Sitio web \url{https://www.docker.com/}} y \textit{Kubernetes}\footnote{Sitio web Kubernetes: \url{https://kubernetes.io/}}.

Otro beneficio añadido es la simple implantación por parte del \gls{administrador} ofreciendo una interfaz web de configuración y mantenimiento amigable donde en la competencia son inexistentes o muy pobres. Así como también al \gls{alumno} se le simplifica la interacción con la aplicación utilizando peticiones web estándar haciendo uso de una \acrshort{api} sin la necesidad de software adicional.

En su conjunto la solución completa que se detalla en la memoria, de fácil extensibilidad, localizada en distintos idiomas y abierta mejoras por parte de la comunidad de desarrollo da pie a otros centros de estudio a considerarla como un herramienta adicional a la enseñanza.

\section{Estructura de la memoria}

La memoria recoge el proceso de ``desarrollo del software'' o ``ciclo de vida del software'' con bloques adicionales que forman parte de un \acrshort{tfg} como lo son el Estado del arte o las Conclusiones. Está dividida en los siguientes capítulos, cada uno con sus objetivos.

\begin{itemize}
	\item \textbf{Estado del arte}: análisis de las alternativas que existen al trabajo planteado. 
	\item \textbf{Análisis del problema}: recopilación de los requerimientos para así llegar a una propuesta que abarque las necesidades actuales de la asignatura \acrshort{lpp}.
	\item \textbf{Diseño de la solución}: descripción de los elementos que forman parte de la solución y el proceso que se ha seguido para la elección de las herramientas utilizadas.
	\item \textbf{Desarrollo de la solución}: enfoque que se ha seguido para el desarrollo del software con sus entregables.
	\item \textbf{Implantación}: enumeración de los pasos a seguir para el despliegue de la solución en una plataforma \foreignlanguage{english}{cloud}.
	\item \textbf{Mantenimiento}: explicación de cómo configurar un entorno de desarrollo local, depurar errores y mantener una calidad de código aceptable. 
	\item \textbf{Extensibilidad}: disertación acerca de las formas en las cuales se pueden añadir funcionalidades nuevas.
	\item \textbf{Conclusiones}: reflexiones finales sobre el \acrshort{tfg} y los objetivos alcanzados.
	\item \textbf{Trabajos futuros}: propuesta de puntos interesantes a tratar en próximas iteraciones o nuevas versiones del software.
\end{itemize}

\section{Convenciones}

En esta memoria se han seguido una serie de convenciones listadas a continuación:

\begin{itemize}
	\item las palabras en inglés que aparecen entre paréntesis a continuación de un término hacen referencia a al objeto en \textit{python} que lo representa en el código fuente.
	\item el código fuente de la aplicación incluido en la memoria tiene en su etiqueta la ubicación del fichero al que hace referencia.
	\item las palabras en inglés están remarcadas en cursiva.
	\item los ficheros del código fuente nombrados en párrafos están remarcados en negrita.
\end{itemize}

\chapter{Estado del arte}

\section{Crítica al estado del arte}


\chapter{Análisis del problema}

Como en todo proyecto de desarrollo de software debemos escoger un modelo o proceso que garantice el éxito y la calidad del producto final. Siguiendo un modelo tradicional el primer paso es la documentación de requisitos \cite{libingreq} en el cual se realiza un análisis que involucra a los usuarios (Actores) que utilizarán el sistema, cada uno con sus necesidades (Requisitos). De este estudio se llegará una especificación funcional del software antes de comenzar a escribir siquiera una linea de código. Una vez terminada esta etapa se irán sucediendo las siguientes en próximos capítulos dado el orden habitual de un ciclo de vida clásico \cite{libingsoft} o en ``cascada'': toma de requisitos, diseño, implementación, pruebas, implantación y mantenimiento.

\section{Actores}

El sistema contará con dos perfiles de usuarios que llamaremos actores, estos son el \Gls{alumno} y el \Gls{administrador}. También veremos que en la memoria se hace mención al ``usuario'' (\foreign{english}{User}), esto se hace para referirnos a funcionalidades que se aplican tanto a \gls{alumno}s como \gls{administrador}es.

\begin{itemize}
    \item \textbf{\gls{alumno}}: el actor principal del sistema. Enviará soluciones a los problemas propuestos y tratará de mejorar sus resultados para subir su ranking en las tablas de posiciones (\foreign{english}{Leaderboard}). Su trabajo será recompensado en forma de puntos e insignias, que son trofeos o marcas obtenidas después de lograr cierto objetivo. Un alumno pertenecerá a un \gls{grupo} (\foreign{english}{Group}), que será el curso en el cual está matriculado, y también podrá formar un \gls{equipo} (\foreign{english}{Team}) con sus compañeros de clase para resolver problemas en conjunto.
	\item \textbf{\gls{administrador}}: el actor que se encarga de poner el sistema en marcha. Tendrá que tener conocimientos sólidos en programación paralela para poder crear \gls{tarea}s que varíen en dificultad y motive al alumnado a mejorar sus resultados. Normalmente será el profesor de la asignatura \acrshort{lpp} o \acrshort{cpa}.
\end{itemize}

Antes de comenzar a listar las \textbf{Historias de usuario} hay dos conceptos importantes a definir que son los de \gls{tarea} (\foreign{english}{Assignment}) y \gls{envio} (\foreign{english}{Request}). La \gls{tarea} este es un problema o ejercicio a resolver en la aplicación con una serie de entradas y una salida (resultado) que el \gls{alumno} desconoce; la \gls{tarea} es creada por el \gls{administrador}. El \gls{envio} es una petición web de un \textit{usuario} hacia la aplicación web con el código fuente a compilar y ejecutar que tratará de dar solución a una \gls{tarea} específica. 

Adicionalmente, cuando en la memoria se haga mención a la palabra \foreign{english}{job}, no nos referiremos a una \gls{tarea} sino al ``trabajo'' que será procesado en una cola (\foreign{english}{queue}) interna o del \foreign{english}{cluster} (\kahan en nuestro caso).

\section{Historias de usuario}

El primer paso es realizar una entrevista con los actores involucrados para describir sus necesidades en un lenguaje sencillo que más adelante darán lugar a los requisitos funcionales (\acrshort{rf})  y no funcionales de la aplicación (\acrshort{rnf}). A esto se le llama \textbf{Historias de usuario}. \par

Para este caso en particular ambos actores fueron interpretados por el tutor y el autor del \acrshort{tfg} intercambiando roles al comienzo de la elaboración de la memoria y el resultado es el siguiente:

\begin{itemize}
	\item Como \gls{alumno}, quiero ingresar al sistema utilizando mis credenciales personales.
	\item Como \gls{alumno}, quiero cambiar mi contraseña.
	\item Como \gls{alumno}, quiero poder registrarme en el sistema.
	\item Como \gls{alumno}, quiero ver un listado de los integrantes de mi \gls{grupo}.
	\item Como \gls{alumno}, quiero ver un listado de mis \gls{tarea}s a resolver.
	\item Como \gls{alumno}, quiero ver el listado de posiciones de mi \gls{grupo}.
	\item Como \gls{alumno}, quiero ver el listado de posiciones de una \gls{tarea}. 
	\item Como \gls{alumno}, quiero poder hacer un \gls{envio} a una de mis \gls{tarea}s asignadas.
	\item Como \gls{alumno}, quiero formar parte de un equipo con otros \gls{alumno}s de mi \gls{grupo}.
	\item Como \gls{alumno}, quiero ver las \gls{insignia}s que he obtenido.
	\item Como \gls{alumno}, quiero acceder a mi perfil para ver toda mi información.
	\item Como \gls{alumno}, quiero visualizar los resultados de los \gls{envio}s.
	\item Como \gls{alumno}, quiero ver un resumen de mi actividad.
	\item Como \gls{alumno}, quiero ver la cantidad de puntos que tengo.
	\item Como \gls{administrador}, quiero crear \gls{grupo}s.
	\item Como \gls{administrador}, quiero borrar \gls{grupo}s.
	\item Como \gls{administrador}, quiero asignar \gls{alumno}s a \gls{grupo}s.
	\item Como \gls{administrador}, quiero crear \gls{alumno}s subiendo un fichero.
	\item Como \gls{administrador}, quiero borrar \gls{alumno}s.
	\item Como \gls{administrador}, quiero restablecer la contraseña de un \gls{alumno}.
	\item Como \gls{administrador}, quiero crear \gls{tarea}s y asignarlas a uno o más \gls{grupo}s.
	\item Como \gls{administrador}, quiero crear \gls{insignia}s y asignarlas a una o más \gls{tarea}s.
	\item Como \gls{administrador}, quiero asignar \gls{insignia}s a una o más \gls{tarea}s.
	\item Como \gls{administrador}, quiero editar \gls{tarea}s.
	\item Como \gls{administrador}, quiero editar \gls{insignia}s.
	\item Como \gls{administrador}, quiero poder configurar la aplicación.
	\item Como \gls{administrador}, quiero desplegar la aplicación en una solución \foreign{english}{cloud}.
\end{itemize}

\section{Requisitos funcionales}

Una vez identificadas las \textbf{Historias de Usuario} más importantes el próximo paso es convertirlas en requisitos funcionales formales, específicos y consistentes. Esto evitará ambigüedades y dejará por sentado cómo se comportará el sistema. Aquí se describen todos los requisitos del aplicativo siguiendo una plantilla adaptada de varios modelos consultados en Internet \cite{link-esp-rq-jan}. A la plantilla creada se le ha añadido un identificador único para dar un seguimiento durante la etapa de desarrollo, pruebas y entrega final; la misma tiene los siguientes apartados:

\begin{itemize}
	\item \textbf{Nombre}: título del requerimiento funcional.
	\item \textbf{Descripción}: objetivo que debe cumplir el requisito.
	\item \textbf{Prioridad}: nivel de importancia. 
	\begin{itemize}
		\item Muy Alta.
		\item Alta.
		\item Media.
		\item Baja.
	\end{itemize}
	
	\item \textbf{Criterio de aceptación}: condiciones que se deben cumplir o satisfacer para que el requisito se considere realizado.
\end{itemize}

\begin{table}[!ht]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-1}} \\
		\hline
		Nombre & Registro de usuarios\\
		\hline
		Descripción & El sistema permitirá el registro de usuarios mediante dirección de correo electrónico   \\
		\hline
		Prioridad & Media\\
		\hline
		Criterio de aceptación & 
		\begin{tabitem}
			\item no puede existir más de un usuario con el mismo correo electrónico
			\item se generará un usuario único con el alias del correo electrónico
			\item se podrá deshabilitar el registro de usuarios mediante configuración del sistema
			\item se podrá limitar el registro de usuarios a correos electrónicos que pertenezcan a dominios específicos (eg: @upv.es, @inf.upv.es)
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-1 Registro de usuarios}
	\label{table:1}
\end{table}

\begin{table}[!ht]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-2}} \\
		\hline
		Nombre & Ingreso de usuarios\\
		\hline
		Descripción & El sistema permitirá el ingreso de usuarios mediante dirección de correo electrónico o nombre de usuario  \\
		\hline
		Prioridad & Muy Alta\\
		\hline
		Criterio de aceptación & 
			solo se podrá ingresar al sistema si la cuenta está activa \\
		\hline
	\end{tabular}
	\caption{RF-2 Ingreso de usuarios}
	\label{table:2}
\end{table}

\begin{table}[!ht]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-3}} \\
		\hline
		Nombre & Equipos\\
		\hline
		Descripción & Los \gls{alumno}s podrán formar parte de un \gls{equipo} con otros compañeros de \gls{grupo}  \\
		\hline
		Prioridad & Baja\\
		\hline
		Criterio de aceptación & 
		\begin{tabitem}
			\item solo se podrá formar parte de un único \gls{equipo} en un momento determinado de tiempo
			\item si un \gls{equipo} no tiene integrantes se eliminará del sistema
			\item los \gls{equipo}s contarán con una URL única que permitirá a otros \gls{alumno}s unirse a los mismos
			\item un \gls{alumno} no puede unirse un \gls{equipo} que no forme parte de su \gls{grupo} o que haya llegado al máximo de integrantes
			\item los \gls{equipo}s tendrán un máximo de integrantes que podrá ser configurado por el \gls{administrador}
			\item un \gls{equipo} se creará desde el perfil de un \gls{alumno}
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-3 Equipos}
	\label{table:3}
\end{table}

\begin{table}[!ht]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-4}} \\
		\hline
		Nombre & Página de Inicio\\
		\hline
		Descripción & Los \gls{alumno}s al ingresar verán un resumen agregado de su estado general en la aplicación   \\
		\hline
		Prioridad &  Alta\\
		\hline
		Criterio de aceptación & La Página de Inicio (\foreign{english}{Dashboard}) del \gls{alumno} deberá mostrar la siguiente información: \newline
		\begin{tabitem}
			\item resumen de los últimos envíos
			\item extracto calculado de cantidad de envíos, tareas, \foreign{english}{quota} disponible (porcentaje de tiempo restante de ejecución) y puntaje
			\item la última insignia obtenida, en caso que no tuviere, alentarlo a completar una tarea para conseguir su primera
			\item los integrantes del equipo, en caso que no tuviere, alentarlo a crear uno nuevo o unirse a uno existente
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-4 Página de Inicio}
	\label{table:4}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-5}} \\
		\hline
		Nombre & Mis Envíos \\
		\hline
		Descripción & Los \textit{usuarios}, tanto \gls{administrador}es como \gls{alumno}s, podrán ver un resumen de sus \gls{envio}s (peticiones web que incluyen el código fuente a ejecutar) \\
		\hline
		Prioridad & Muy Alta\\
		\hline
		Criterio de aceptación & El resumen de \gls{envio}s se visualizará en forma de tabla, se podrá filtrar por la información disponible y deberá mostrar las siguientes columnas: \newline
		\begin{tabitem}
			\item ID único en el sistema
			\item Fecha y Hora de envío
			\item Tarea a la que corresponde
			\item Estado del envío
			\item Puntaje obtenido
			\item Tiempo de ejecución
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-5 Mis Envíos}
	\label{table:5}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-6}} \\
		\hline
		Nombre & Visualización de Envío \\
		\hline
		Descripción & Al realizar un \gls{envio}, un \textit{usuario} podrá navegar a una URL única para ver toda la información disponible y hacer el seguimiento de su estado  \\
		\hline
		Prioridad & Alta\\
		\hline
		Criterio de aceptación & Se deben mostrar los siguientes apartados e información y cumplir con las siguientes restricciones y funcionalidades: \newline  
		\begin{tabitem}
			\item código fuente
			\item análisis estático del código fuente enviado
			\item resultado del código ejecutado (\foreign{english}{output} de la consola o terminal)
			\item tiempo de ejecución y status
			\item cada \gls{envio} tiene un ID único que no puede ser repetido en el sistema
			\item un \gls{envio} solo puede ser visualizado por el autor o un \textit{usuario} con Rol de \gls{administrador} 
		\end{tabitem}  \\
		\hline
	\end{tabular}
	\caption{RF-6 Visualización de Envío}
	\label{table:6}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-7}} \\
		\hline
		Nombre & Visualización de Tareas \\
		\hline
		Descripción  & Todos los \textit{usuarios} podrán acceder a un apartado donde se muestre un listado en forma de resumen de las \gls{tarea}s disponibles \\
		\hline
		Prioridad &  Alta\\
		\hline
		Criterio de aceptación & Se deben mostrar los siguientes apartados e información: \newline  
		\begin{tabitem}
			\item si el usuario es un \gls{alumno} se deben mostrar las tareas asignadas a su grupo
			\item si el usuario es un \gls{administrador} se deben mostrar todas las tareas en el sistema
			\item por cada \gls{tarea} debe haber un resumen, insignias y últimos envíos
			\item no se deben mostrar las \gls{insignia}s secretas
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-7 Visualización de Tareas}
	\label{table:7}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-8}} \\
		\hline
		Nombre & Tarea \\
		\hline
		Descripción  & Visualización de Tarea a completar con su descripción completa \\
		\hline
		Prioridad &  Alta\\
		\hline
		Criterio de aceptación & Se deben mostrar los siguientes apartados e información: \newline  
		\begin{tabitem}
			\item descripción completa
			\item \gls{insignia}s a obtener
			\item \gls{insignia}s secretas que el usuario ha obtenido
			\item status de la \gls{tarea}: abre pronto, abierto, cierra pronto, cerrada
			\item si el \textit{usuario} ha realizado un \gls{envio} que ha finalizado una ejecución satisfactoria se le debe informar en un mensaje
			\item enlace para hacer un envío con sus credenciales
			\item enlace a la tabla de posiciones
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-8 Tarea}
	\label{table:8}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-9}} \\
		\hline
		Nombre   & Envío \\
		\hline
		Descripción  & \acrshort{api} disponible a los \textit{usuarios} para las peticiones web que contienen código fuente  \\
		\hline
		Prioridad &  Muy Alta\\
		\hline
		Criterio de aceptación & El código enviado debe compilarse, ejecutarse y su resultado verificado con la \gls{tarea} que tiene asignada.
		La API creada para el \gls{envio} de código fuente debe cumplir con los siguientes apartados: \newline
		\begin{tabitem}
			\item las peticiones deben ser seguran con la utilización de un token único por usuario
			\item la URL de envío debe ser única por \gls{tarea}
			\item si el usuario es un \gls{alumno} se debe limitar la cantidad de peticiones que puede hacer en una franja de tiempo determinada (segundos)
			\item si el usuario es un \gls{alumno} debe verificarse que la \gls{tarea} esté asignada a su \gls{grupo} y se encuentra abierta para recibir peticiones
			\item si el usuario es un \gls{administrador} no debe existir ningún tipo de limitación en las peticiones web
			\item dependiendo el resultado de la ejecución de un \gls{envio} se le deben asignar los puntos correspondientes
			\item las respuestas deben ser en formato \acrshort{json}\footnote{Sitio web JSON: \url{https://tools.ietf.org/html/rfc7159}}
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-9 Envío}
	\label{table:9}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-10}} \\
		\hline
		Nombre & Tabla de Posiciones \\
		\hline
		Descripción & Página en la cual se muestran las posiciones por \gls{tarea} y \gls{grupo} en formato de tabla\\
		\hline
		Prioridad & Alta\\
		\hline
		Criterio de aceptación & 
		\begin{tabitem}
			\item los \gls{alumno}s solo pueden visualizar las tablas de posiciones de sus \gls{tarea}s asignadas y el \gls{grupo} al que pertenecen
			\item los \gls{administrador}es pueden filtrar las tablas de posiciones por \gls{grupo}s
			\item la posición de un \gls{envio} en una \gls{tarea} está dada por el tiempo de ejecución, a menor tiempo de ejecución, mejor posicionada
			\item la posición de un \gls{alumno} en una tabla de posición de \gls{grupo} está dada por la cantidad de puntos que lleva acumulado, mientras más puntos, mejor posición
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-10 Tabla de Posiciones}
	\label{table:10}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-11}} \\
		\hline
		Nombre & Perfil \\
		\hline
		Descripción & Un \textit{usuario} del sistema tiene su perfil donde puede ver un resumen de su actividad, cambiar su contraseña, ver al \gls{grupo} al que pertenece, cambiar el token de \gls{envio} de \gls{tarea}s y su puntaje acumulado  \\
		\hline
		Prioridad & Media\\
		\hline
		Criterio de aceptación & Se debe mostrar la siguiente información: \newline
		\begin{tabitem}
			\item aparado con un resumen de actividad con los \gls{envio}s realizados y las \gls{insignia}s obtenidas
			\item apartado para cambiar la contraseña
			\item apartado para generar un nuevo token
			\item apartado para ver los integrantes de su \gls{grupo}
			\item apartado de \gls{insignia}s obtenidas
			\item un resumen de los puntos acumulados y cantidad de \gls{envio}s realizados
			\item equipo al que pertenece con sus integrantes
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-11 Perfil}
	\label{table:11}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-12}} \\
		\hline
		Nombre & Insignias \\
		\hline
		Descripción & Trofeo o marca que se le asigna a un \gls{alumno} cuando se cumple una condición al procesarse un \gls{envio}  \\
		\hline
		Prioridad & Media\\
		\hline
		Criterio de aceptación & Una Insignia tiene las siguientes restricciones \newline
		\begin{tabitem}
			\item se debe asignar de forma dinámica a través de una regla al terminarse el proceso de un envío.
			\item un \gls{alumno} puede obtener una \gls{insignia} específica una única vez.
			\item una ejecución fallida (TIMEWALL o ERROR) pueden ser condiciones para asignarlas.
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-12 Perfil}
	\label{table:12}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-13}} \\
		\hline
		Nombre & Configuración del Sistema \\
		\hline
		Descripción & Apartado con el resumen de todos los parámetros de despliegue de la aplicación \\
		\hline
		Prioridad & Baja\\
		\hline
		Criterio de aceptación & Se debe mostrar en forma de tabla todos los parámetros de despliegue de la aplicación en formato clave:valor. Esta página solo puede ser accedida por un \gls{administrador} \\
		\hline
	\end{tabular}
	\caption{RF-13 Configuración del Sistema \\}
	\label{table:13}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-14}} \\
		\hline
		Nombre & Administración de Envíos \\
		\hline
		Descripción & Página con un listado de todos los \gls{envio}s que han sido procesados por el sistema \\
		\hline
		Prioridad & Alta\\
		\hline
		Criterio de aceptación & Solo los \gls{administrador}es pueden acceder a esta página. \newline 
		El listado de \gls{envio}s debe contener la siguiente información \newline
		\begin{tabitem}
			\item ID único del sistema con su URL única
			\item fecha y hora de envío
			\item \textit{usuario} que ha realizado el \gls{envio} con su correo y grupo al que pertenece si es un \gls{alumno}
			\item \gls{tarea} a la cual pertenece el \gls{envio}
			\item \foreign{english}{status} del \gls{envio} (en espera, encolado, en ejecución, error, etc..)
			\item puntos que se han asignado al \gls{envio}
			\item tiempo de ejecución
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-14 Administración de Envíos}
	\label{table:14}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-15}} \\
		\hline
		Nombre & Administración de Grupos \\
		\hline
		Descripción & Página con un listado de los \gls{grupo}s de \gls{alumno}s \\
		\hline
		Prioridad & Media\\
		\hline
		Criterio de aceptación & 
		Se debe poder crear nuevos \gls{grupo}s con un código único y descripción, además de poder eliminarlos. \newline
		Solo los \gls{administrador}es pueden acceder a esta página. \newline
		El listado debe contener la siguiente información \newline
		\begin{tabitem}
			\item código único
			\item descripción
			\item cantidad de \gls{alumno}s asignados al \gls{grupo}
			\item listado de \gls{tarea}s asignadas al \gls{grupo}
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-15 Administración de Grupos}
	\label{table:15}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-16}} \\
		\hline
		Nombre & Administración de colas internas \\
		\hline
		Descripción & Página con información del estado de las colas internas de la aplicación \\
		\hline
		Prioridad & Alta\\
		\hline
		Criterio de aceptación & Solo los \gls{administrador}es pueden acceder a esta página. \newline
		Debe mostrarse una resumen con la siguiente información y funcionalidades: \newline
		\begin{tabitem}
			\item colas internas disponibles y su estado
			\item información sobre las \foreign{english}{jobs} en las colas.
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-16 Administración de colas internas \\}
	\label{table:16}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-17}} \\
		\hline
		Nombre & Administración de Alumnos \\
		\hline
		Descripción & página con un listado de todos los \gls{alumno}s del sistema  \\
		\hline
		Prioridad & Alta\\
		\hline
		Criterio de aceptación & Solo los \gls{administrador}es pueden acceder a esta página. \newline
		Se debe poder borrar \gls{alumno}s del sistema y regenerar sus contraseñas. \newline
		El listado de \gls{alumno}s debe contener la siguiente información: \newline
		\begin{tabitem}
			\item nombre de usuario, correo y nombre
			\item grupo al que pertenece
			\item \foreignlanguage{english}{quota} disponible
			\item puntos
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-17 Administración de Alumnos}
	\label{table:17}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-18}} \\
		\hline
		Nombre & Administración de Tareas \\
		\hline
		Descripción & Página con listado de todas las \gls{tarea}s disponibles en el sistema en formato de tabla  \\
		\hline
		Prioridad & Alta\\
		\hline
		Criterio de aceptación & Solo los \gls{administrador}es pueden acceder a esta página. \newline
		Posibilidad de crear una nueva \gls{tarea}. \newline
		La información que debe mostrar la tabla es la siguiente: \newline
		\begin{tabitem}
			\item ID único
			\item status de la \gls{tarea}: abierta o cerrada
			\item nombre
			\item título
			\item cantidad de \gls{envio}s
			\item fecha de inicio y fin
			\item \gls{grupo}s a la cual está asignada
			\item URL para la edición
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-18 Administración de Tareas}
	\label{table:18}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-19}} \\
		\hline
		Nombre & Creación y edición de Tarea \\
		\hline
		Descripción & Página donde se puede crear una nueva \gls{tarea} o editar una ya existente en el sistema con un editor HTML para la descripción de la misma \\
		\hline
		Prioridad & Muy Alta\\
		\hline
		Criterio de aceptación & Solo los \gls{administrador}es pueden acceder a esta página. \newline
		Se puede eliminar una \gls{tarea} desde la edición. \newline
		Se debe poder insertar código fuente para una mejor visualización en la descripción. \newline
		Se pueden añadir ficheros adjuntos que serán copiados al cluster \kahan junto al código fuente a ejecutar de un \gls{envio}. \newline
		Los campos disponibles en la creación o edición de una \gls{tarea} son los siguientes: \newline
		\begin{tabitem}
			\item nombre único
			\item título
			\item fecha de inicio y fin
			\item puntos a asignar en caso de un resultado satisfactorio
			\item editor texto para la descripción de la \gls{tarea} en formato HTML
			\item resultado esperado de la ejecución
			\item listado de \gls{grupo}s a asignar la tarea
			\item listado de \gls{insignia}s que se pueden obtener en la \gls{tarea}
			\item ficheros adjuntos
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-19 Creación y edición de Tarea}
	\label{table:19}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RF-20}} \\
		\hline
		Nombre   & FAQ \\
		\hline
		Descripción  & Página con preguntas frecuentes que se pueden hacer los usuarios del sistema y sus respuestas  \\
		\hline
		Prioridad &  Baja\\
		\hline
		Criterio de aceptación & 
		\begin{tabitem}
			\item debe estar localizado en al menos 2 idiomas
			\item no debe contener más de 10 preguntas
		\end{tabitem} \\
		\hline
	\end{tabular}
	\caption{RF-20 FAQ}
	\label{table:20}
\end{table}

\FloatBarrier

\section{Requisitos no funcionales}

Los requisitos no funcionales son criterios que se deben cumplir para juzgar la correcta operación del sistema; en contraste con los requisitos funcionales no definen comportamientos específicos. \par

Para las siguientes tablas también se ha creado una plantilla estándar similar a la de requisitos funcionales pero con menos atributos y la definición de los mismos es la misma de las tablas vistas anteriormente.

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RNF-1}} \\
		\hline
		Nombre   & Usabilidad \\
		\hline
		Descripción  & El sitio web deberá tener una interfaz sencilla y fácil de utilizar. \\
		\hline
		Prioridad &  Muy Alta \\
		\hline
	\end{tabular}
	\caption{RNF-1 Usabilidad}
	\label{table:21}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RNF-2}} \\
		\hline
		Nombre   & Implantación \\
		\hline
		Descripción  & El aplicativo debe poder implantarse de forma automatizada \\
		\hline
		Prioridad &  Media \\
		\hline
	\end{tabular}
	\caption{RNF-2 Implantación}
	\label{table:22}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RNF-3}} \\
		\hline
		Nombre   & Configuración \\
		\hline
		Descripción  & El aplicativo debe permitir configurar los parámetros de despliegue y uso \\
		\hline
		Prioridad &  Alta \\
		\hline
	\end{tabular}
	\caption{RNF-3 Configuración}
	\label{table:23}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RNF-4}} \\
		\hline
		Nombre   & Localización \\
		\hline
		Descripción  & El aplicativo debe soportar la localización en diferentes idiomas \\
		\hline
		Prioridad &  Media \\
		\hline
	\end{tabular}
	\caption{RNF-4 Localización}
	\label{table:24}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RNF-5}} \\
		\hline
		Nombre & Almacenamiento \\
		\hline
		Descripción  & Toda la información de la aplicación debe ser persistida en una \acrfull{bd} y el código fuente almacenado en un sistema de ficheros \\
		\hline
		Prioridad &  Muy alta \\
		\hline
	\end{tabular}
	\caption{RNF-5 Almacenamiento}
	\label{table:25}
\end{table}

\begin{table}[ht!]
	\centering
	\begin{tabular}{ |p{4cm}||p{10cm}|  }
		\multicolumn{2}{l}{\textbf{RNF-6}} \\
		\hline
		Nombre & Comunicación \\
		\hline
		Descripción  & Todas las comunicaciones con sistemas externos deben realizarse con protocolos seguros. \\
		\hline
		Prioridad &  Muy alta \\
		\hline
	\end{tabular}
	\caption{RNF-6 Comunicación}
	\label{table:26}
\end{table}

\section{Bocetos}

Como parte del análisis del problema se han realizado bocetos de la interfaz web de algunos de los requisitos funcionales que tienen una gran cantidad de información a mostrar. Estos bocetos se llaman \foreign{english}{wireframes} y representan de forma sencilla la estructura de una página web. No se espera que muestren el diseño final o que sean perfectos estéticamente ya que su cometido es aportar claridad, detectar problemas de usabilidad y crear una conexión entre los requisitos e información con la interfaz.

Los bocetos corresponden a los requisitos funcionales Página de inicio (RF-4) para la Figura \ref{figura:wireframe-dashboard}, Tarea (RF-8) para la Figura \ref{figura:wireframe-tarea} y Perfil (RF-11) para la Figura \ref{figura:wireframe-perfil}.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.95\textwidth]{img/wireframe-tarea}
	\caption[Boceto Tarea]{Boceto Tarea (RF-8)}
	\label{figura:wireframe-tarea}
\end{figure}

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.9\textwidth]{img/wireframe-dashboard}
	\caption[Boceto Página de inicio]{Boceto Página de inicio (RF-4)}
	\label{figura:wireframe-dashboard}
\end{figure}

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.9\textwidth]{img/wireframe-perfil}
	\caption[Boceto Perfil]{Boceto Perfil (RF-11)}
	\label{figura:wireframe-perfil}
\end{figure}

\FloatBarrier

%\section{Cluster \kahan}
\section{Clusters de computadoras }
El objeto de la aplicación es el de ejecutar trabajos (\foreign{english}{jobs}) en un \foreign{english}{cluster} de computadoras. Estas configuraciones están formadas por nodos de computación unidos entre sí mediante redes de alta velocidad. Su programación está basada en el paradigma conocido como \emph{programación en memoria distribuida} donde todos los nodos ejecutan el mismo código, particularizado por un identificador de proceso (valor de 0 a $p$-1, siendo $p$ el número de nodos) y se intercambian datos entre sí mediante paso explícito de mensajes. La programación de este tipo de configuraciones suele realizarse utilizando MPI (Message Passing Interface), una librería que permite la programación de estos equipos siguiendo el paradigma mencionado. Es usual que estos equipos dispongan de un nodo principal llamado \textit{Frontend}, al cuál se conectan los usuarios mediante una conexión \texttt{ssh} para desarrollar código y lanzar el programa que se ejecutará en los nodos de cómputo. 

En este trabajo utilizaremos un \foreign{english}{cluster} de computadores particular, como ejemplo de uso y representante de este tipo de configuraciones, denominado \kahan. El \foreign{english}{cluster} \kahan es un \foreign{english}{cluster} de computación perteneciente a la \acrshort{upv}~\cite{link-cluster-kahan} y será el encargado de procesar el código que envíen los alumnos a la aplicación web. Consta de un nodo cabecera (\textit{Frontend}) a la que un usuario se puede conectar mediante escritorio remoto o consola y así enviar el trabajo a procesar en alguna de sus colas. El nodo \textit{Frontend} es el encargado de comunicarse con el \foreign{english}{cluster} de 6 nodos y procesar los envíos.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.8\textwidth]{img/kahan-cluster}
	\caption[Diagrama del cluster \kahan]{Diagrama del cluster \kahan}
	\label{figura:kahan-cluster}
\end{figure}

En las prácticas de las asignaturas de \acrshort{lpp} y \acrshort{cpa} la ejecución de los pasos de conexión al \textit{Frontend}, envío de código a una cola, revisión de estado de la ejecución y descarga de resultados es un trabajo manual que inclusive llega a ser tedioso ya que los tiempos en los cuales será procesada nuestra petición varía según el uso y estado actual de las colas en \kahan. Por esto, uno de los puntos más importantes que vale la pena remarcar dada su complejidad será lograr que la aplicación se encargue de la comunicación con el \foreign{english}{cluster} realizando el proceso completo de forma automatizada, añadiendo también la verificación de resultados y así ofrecer una mejor experiencia de usuario. 

Además, el proceso de interacción con el \foreign{english}{cluster} \kahan debe ser asíncrono y no bloquear el funcionamiento de la aplicación web y la mejor forma de lograr esto es disponer de un \textit{Administrador de Tareas}, que en la práctica es un sistema de colas donde se envían ``trabajos'' (\foreign{english}{jobs}) a procesarse en un determinado momento de tiempo.

El trabajo, no obstante, se ha desarrollado con la idea puesta en su extensibilidad a cualquier otro \foreign{english}{cluster}. De hecho, el  \foreign{english}{cluster} \kahan va a ser sustituido este curso que viene por \textit{kahan2}, que será más avanzado y ligeramente diferente del actual. El trabajo realizado aquí, por tanto, está preparado para ser migrado al nuevo  \foreign{english}{cluster} con mínimas modificaciones.

\section{Riesgos}

Un análisis de riesgo también forma parte del estudio del problema ya que se debe evaluar si el resultado esperado es realizable en tiempo y forma. En el listado de requisitos anterior se pueden identificar tres puntos críticos ya que tienen una complejidad alta.

En primer lugar, la interacción con el \foreign{english}{cluster} \kahan puede ser dificultosa. Por un lado, porque es posible que no se disponga del software adecuado en el \emph{Frontend} para la instalación de la aplicación o porque los administradores del sistema no tengan la capacitación para instalar dicho software. Por otro lado, porque la solución a lo anterior significa el acceso de la aplicación desde un sistema externo. Además, hay que sumarle la posibilidad de que la aplicación se despliegue en una solución \foreign{english}{cloud}, siendo el autor de la memoria un usuario novel de esos sistemas. Y por último la verificación de resultados, asignación de \gls{insignia}s y tablas de posiciones (\foreign{english}{Leaderboards}) que pueden ir cambiando en el tiempo.

Para mitigar riesgos se ha seguido un plan de acción con el apoyo del Tutor. En el primer caso se han hecho pruebas utilizando los protocolos \acrshort{ssh} y \acrfull{scp} para replicar los pasos manuales que haría un \gls{alumno} en una práctica de una asignatura como \acrshort{lpp} o \acrshort{cpa} y verificar que pueden ser automatizados. El Autor por su parte ha participado de un curso online \cite{link-coursera-google} sobre la solución \foreign{english}{cloud} escogida para mejorar su base de conocimiento; y, por último, se han analizado las librerías disponibles del \foreign{english}{software} a utilizar para simplificar las tareas complejas expuestas previamente.

Una vez realizadas estas tareas y viendo que el riesgo remanente es bajo se ha optado por continuar con el calendario de entrega del \acrshort{tfg} en la fecha acordada.

\section{Análisis del marco legal y ético}

Como este es un proyecto de código abierto se ha escogido la Licencia MIT\footnote{Licencia MIT: \url{https://opensource.org/licenses/MIT}.} ya que es una de las más permisivas para fomentar la reutilización y colaboración. Este tipo de licencia permite el libre uso de forma privada o comercial, la modificación y distribución del código sin ningún tipo de garantía donde solo se pide que se mantengan las menciones a la licencia y derechos de autor.

Además, todos los elementos utilizados en el producto final que no son creación del Autor de este \acrshort{tfg}, como librerías \textit{javascript} e imágenes, son de libre uso y tienen su atribución correspondiente.

\section{Plan de Trabajo}

Después de haber revisado el listado de todos los requerimientos funcionales se ha creado un resumen agrupado a alto nivel para dar un seguimiento sin la necesidad de una herramienta externa. El listado se ha subido como parte del fichero \textbf{README.md} del repositorio de código y permite tanto al Tutor como al Autor del \acrshort{tfg} ver el estado del desarrollo y cuáles son los tópicos a abordar en el paso siguiente.

Con el uso del listado y una reunión semanal vía \textit{Skype} se ha seguido el siguiente protocolo: 1) revisión de las funcionalidades implementadas mediante una \foreign{english}{demo}; 2) ronda de preguntas y dudas a resolver; 3) acuerdo entre partes de las próximas funcionalidades a implementar para la próxima semana.

Debido a ciertas dificultades presentadas en el proceso de desarrollo y el esfuerzo que podía realizar el Autor (tiempo libre disponible) debido a la carga de su trabajo actual se ha ido pivotando entre las prioridades cada semana. Desde un punto de vista de proceso se puede asumir que se ha seguido un Desarrollo Ágil, similar al de \textit{Scrum}, seleccionando un listado de tareas a abordar en un \textit{sprint} (iteración para entregar ``valor'') con una duración de una semana. 

\textit{Scrum}, como metodología de Desarrollo Ágil, se centra en tener un \textit{software} en funcionamiento antes que seguir un proceso rígido de desarrollo; premiando así la entrega constante y la posibilidad de adecuarse al cambio. 


\chapter{Diseño de la solución}

Una vez analizados los requisitos funcionales y no funcionales el próximo paso consiste en plantear el diseño de la aplicación. Aunque la finalidad de este trabajo es la creación de una aplicación web existen elementos adicionales que deben considerarse para cumplir con el objetivo ya que, aunque el punto de entrada de interacción del sistema será una página web, toda la información se tendrá que alojar en una \acrfull{bd} y los \gls{envio}s que contienen ficheros con código fuente para la resolución de \Gls{tarea}s deberán guardarse en un \acrfull{nfs}. Estos elementos junto a otros más forman parte de lo que será la \textbf{Arquitectura de la solución}. Pero antes de llegar a esto hay que comprender cómo será la \textbf{Interacción del Sistema} y decidir el \textbf{Software} a utilizar que lo haga posible. %\par

Además, para alojar y recuperar información de una \acrshort{bd} debemos crear unos modelos que representen a todos los objetos que interactúan dentro del sistema, lo que se conoce como \textbf{Modelo de Datos}. Por último, la interacción con el \foreign{english}{cluster} \kahan es tan importante que tendremos que incluir un \textit{Administrador de Tareas} para el procesamiento de \foreign{english}{jobs} de forma asíncrona como un \textbf{Sistema de Colas interno}.

\section{Interacción del Sistema}

En la introducción del capítulo se han visto algunos elementos de la aplicación y es importante realizar un bosquejo de cómo será la interacción entre ellos para modelar la solución de forma correcta. Haciendo un repaso podemos encontrar los siguientes:

\begin{itemize}
	\item La aplicación web con la que interactúan los usuarios.
	\item La \acrfull{bd} donde se guarda la información.
	\item Un \acrfull{nfs} para alojar los ficheros con código fuente de los \gls{envio}s.
	\item Un \textit{Administrador de Tareas} basado en un sistema de colas.
	\item El \foreign{english}{cluster} \kahan del \acrshort{dsic}.
\end{itemize} 

Una interacción habitual sería la que se muestra en la Figura~\ref{figura:modelado-interaccion}, donde el \textit{Administrador de Tareas} es el encargado de la comunicación con el sistema de colas de \kahan para actualizar el \foreign{english}{status} del \gls{envio}. A partir de aquí ya queda clara la importancia de una separación de roles entre lo que será el \foreign{english}{frontend} o punto de interacción de los usuarios con la aplicación y el procesamiento de \gls{envio}s. Esto tendrá vital importancia en la elección del software a utilizar.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.95\textwidth]{img/modelado-interaccion}
    \caption[Modelado Interacción entre elementos del sistema]{Interacción entre elementos del sistema.}
	\label{figura:modelado-interaccion}
\end{figure}

\section{Tecnología utilizada}

Como hemos visto en el apartado \textbf{Estado del Arte} la única herramienta similar a la aplicación web a desarrollar es \textit{Tablón}, no sin sus muchas limitaciones y problemas que ya hemos expuesto previamente. Sin embargo, \textit{Tablón} es un buen punto de partida porque ya ha sido utilizado previamente por el Tutor en la asignatura de \acrshort{lpp}, y algunos de los requisitos funcionales, como la Tabla de Posiciones (RF-10), ya existen y pueden servir como inspiración.

Dadas las limitaciones que tiene \textit{Tablón}, una de las aspiraciones en la creación de esta aplicación web para concursos de programación paralela es que sea su sucesor (o reemplazo) a futuro. Por esto mismo he decidido llamar a la aplicación web \textit{Pizarra}, en honor a \textit{Tablón}, y de aquí en adelante, cuando se mencione \textit{Pizarra}, se hará referencia a la aplicación web y otros elementos adicionales necesarios para su funcionamiento. 

El lenguaje de programación a utlizar será \textit{python}, ya conocido por el Autor y con una extensa cantidad de \gls{paquete}s, que son librerías que añaden funcionalidades extra y que serán de gran utilidad para acelerar los tiempos de desarrollo. 

Dado que ya hemos abordado la \textbf{Interacción del Sistema} a alto nivel solo resta escoger el \textbf{Software} que dará vida a la aplicación web y al \textit{Administrador de Tareas}. Debido a una experiencia previa en otra asignatura de estudios de grado, he decido optar por \textit{Flask}\footnote{Sitio web Flask: \url{https://flask.palletsprojects.com/en/1.1.x/}.}, un micro-framework de \textit{python} con gran acogida por la comunidad de desarrollo que incluye un sistema de plantillas para la generación de páginas web llamado \text{Jinja}\footnote{Sitio web Jinja: \url{https://jinja.palletsprojects.com/en/2.11.x/}}. 

En cuanto al \textit{Administrador de Tareas}, existen diferentes \gls{paquete}s en \textit{python} para crear un \textbf{Sistema de Colas interno}. En este caso se ha optado por \textit{RQ}\footnote{Sitio web RQ: \url{https://python-rq.org/}.} (Redis Queue), que utiliza pocos recursos y permite que los ``trabajos'' o \foreign{english}{jobs} se procesen en determinado tiempo futuro, funcionalidad que será útil para revisar los resultados de ejecuciones en \kahan. \textit{RQ} permitirá desacoplar las \gls{cola}s del aplicativo web al utilizar un servicio de \textit{Redis} como repositorio de \foreign{english}{jobs}, además de disponer de un panel de control (\foreign{english}{dashboard}) que puede ser embebido en cualquier aplicación web.

\section{Arquitectura del Sistema}

Para el despliegue de aplicaciones basadas en \textit{Flask} existe una lista de recomendaciones que debemos seguir~\cite{link-deploy-flask}. En primer lugar, \textit{Flask} no está optimizado para aceptar peticiones web directamente de un navegador ya que utiliza la \acrfull{wsgi} para mostrar el contenido web de sus aplicaciones, siendo \acrshort{wsgi} un estándar de \textit{python} que permite a cualquier aplicación comunicarse a través del protocolo \acrshort{http}, es decir, Internet. 

\begin{figure}[!t]
	\centering
	\includegraphics[width=0.95\textwidth]{img/infrastructure-pizarra}
    \caption[Arquitectura del Sistema]{Arquitectura del Sistema.}
	\label{figura:infrastructure-pizarra}
\end{figure}

Además, la ejecución sin más de un \foreign{english}{script} en \textit{python} no es una buena práctica ya que una excepción del sistema u otras situaciones anormales que puedan producirse puede abortar el proceso. Para estos casos existe Gunicorn\footnote{Sitio Web Gunicorn: \url{https://gunicorn.org/}.}, que funciona como un servidor de aplicaciones y se encarga de ser el intermediario entre una petición web y \textit{Flask}, además de monitorear el servicio y reiniciarlo en caso de problemas.

Otra buena práctica al realizar un despliegue es poner nuestra aplicación detrás de un proxy reverso, esto es, un Servidor Web que se encargue de administrar las conexiones y servir los certificados digitales y ficheros estáticos. Este tipo de arquitectura brinda una mejora en el rendimiento global del sistema y una separación de roles donde cada capa o \foreign{english}{layer} tiene una tarea específica. Para la arquitectura actual se ha escogido NGix\footnote{Sitio web Ngix: \url{https://www.nginx.com/}.}, uno de los servidores webs más utilizados en Internet.

Ya se ha menciado que el \gls{paquete} \textit{RQ} utiliza un servicio de \textit{Redis} para el \textbf{Sistema de Colas interno}, pero además brinda una funcionalidad extra llamada \foreign{english}{Worker} o ``trabajador'': un proceso en \textit{python} que se ejecuta como un proceso en segundo plano con el único objetivo de procesar los \foreign{english}{jobs} de una \gls{cola}. El uso de estos \foreign{english}{Workers} no tiene límite y permite un uso ``elástico'' de los recursos, aumentando y disminuyendo su cantidad dependiendo la cantidad de \foreign{english}{jobs} a procesar.

Existen tres elementos de la arquitectura que necesitan de almacenamiento: 1) la aplicación web, para guardar los ficheros adjuntos de las \gls{tarea}s y el código fuente de los \gls{envio}s, 2) los \foreign{english}{Workers}, que deben poder acceder al código fuente para transferirlo a \kahan, y 3) la \acrlong{bd}, para almacenar las tablas.

Por último, todos los elementos estarán desplegados en forma de \textit{contenedores} Docker, un sistema que empaqueta el \foreign{english}{software} con todo lo necesario para que se ejecute y que es explicado en detalle en el Capítulo 6 dedicado a la \textbf{Implantación}.

\section {Modelo de datos}

Una de las formas habituales de trabajar con \acrshort{bd} en \textit{python} es utilizar un \foreign{english}{Object-Relational mappi ng} (\acrshort{orm})  que transforma clases que representan una entidad o modelo a una estructura de datos relacional. La librería a utilizar será \textit{SQLAlchemy}, un \acrshort{orm} que soporta varios motores de \acrshort{bd}, entre otros SQLite, MySQL, PostgreSQL, Oracle o MS SQL. En este caso se ha optado por SQLite para el entorno de desarrollo local (se crea el fichero \textit{database.db} en el directorio raíz del aplicativo), y PostgreSQL, para un entorno productivo.

SQLite porque no necesita tener iniciado un proceso en la máquina ya que se escribe directamente a disco con un conector (\foreign{english}{driver}) y es ultra liviano en el uso de recursos ya sean memoria y espacio en disco. PostgreSQL tiene todas las características de un motor de \acrshort{bd} robusto al nivel de otras soluciones comerciales, ofrece una imagen de \textit{Docker} y no es necesario implementar un modelo de replicación. Otra añadido es que ambas herramientas son de libre uso y tienen soporte continuo de la comunidad.

Dados los requerimientos funcionales, se han identificado y creado las siguientes clases de \textit{python} que, mediante el uso de \textit{SQLAlchemy}, podrán ser persistentes, consultadas y actualizadas en la \acrfull{bd}.

\begin{itemize}
	\item \textbf{User}: \textit{usuario} del sistema.
	\item \textbf{Role}: roles del sistema, en este caso \gls{alumno} y \gls{administrador}.
	\item \textbf{Team}: \gls{alumno} que forman un \gls{equipo}.
	\item \textbf{ClassGroup}: \gls{grupo} de \gls{alumno}s que representan una clase en particular.
	\item \textbf{Badge}: \Gls{insignia} obtenida al completarse objetivos.
	\item \textbf{Request}: \gls{envio} de código fuente de un usuario a una \Gls{tarea}.
	\item \textbf{Assignment}: \Gls{tarea} a resolver, puede estar asignada a uno o más grupos.
	\item \textbf{LeaderBoard}: marcador de posiciones para una \Gls{tarea} y \Gls{grupo} específico.
	\item \textbf{Attachment}: fichero adjunto añadido a una \Gls{tarea}.
	\item \textbf{Job}: trabajo a procesar, utilizada por la \Gls{cola} interna de \textit{Pizarra}.
\end{itemize}

Los modelos expuestos previamente se pueden encontrar en el fichero \textbf{models.py} siguiendo el estándar de \textit{Flask} y se expresan como clases que extienden de la clase \textit{db.Model} del paquete de \textit{SQLAlchemy}. Esto permite la serialización del objeto y su persistencia en la \Gls{bd}. 

Se muestra a continuación, como ejemplo, la representación de un \gls{equipo} (\foreign{english}{Team}):

\begin{code}{models.py}
	...
	class Team(db.Model):
	"""
	Represents a Team of students in the database
	A Student can be a part of only one team
	A Team can have many students
	"""
	__tablename__ = 'team'
	id = Column(Integer, primary_key=True)
	name = Column(String, unique=True)
	key = Column(String)
	members = relationship('User', back_populates='team')
	...
\end{code}

En el código expuesto se pueden identificar los siguientes elementos:

\begin{itemize}
	\item la clase \textit{Team} extendiendo la clase \textit{db.Model},
	\item una descripción de la clase y su propósito enmarcada en comentarios,
	\item el nombre de la tabla para persistir el objeto una vez serializado,
	\item las diferentes columnas de la tabla con sus atributos (si es clave primaria, clave única y el tipo de datos), y
    \item la relación entre \textit{Team} y \textit{User} (un \gls{equipo} tiene integrantes y un \gls{alumno} es parte de un \gls{equipo}).
\end{itemize}

Una vez definidos todas las clases con sus relaciones, podemos generar un diagrama de la \Gls{bd}. Esto facilita la comprensión y ofrece una mejor visión general. Utilizando una herramienta ya incluida en el \acrshort{ide} de desarrollo \textit{PyCharm}\footnote{Sitio web Pycharm: \url{https://www.jetbrains.com/pycharm/}.} se obtiene la Figura~\ref{figura:database-uml-diagram}.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.95\textwidth]{img/database-uml-diagram}
    \caption[Diagrama UML de la Base de Datos]{Diagrama UML de la Base de Datos.}
	\label{figura:database-uml-diagram}
\end{figure}

Al ser las tablas de la \acrshort{bd} objetos serializados de \textit{python}, podemos asumir que la figura generada es la misma representación de un diagrama de clases en \acrfull{uml}: una estructura que muestra las relaciones de las clases dentro del sistema, sus atributos y métodos u operaciones.

\section{Diseño de la Aplicación en Flask}

Al crear una nueva aplicación en \textit{Flask}, existen ciertos patrones o mejores prácticas a seguir. Entre ellas se encuentra la utilización de uno de los patrones de diseño más comunes en la ingeniería de software, \acrlong{mvc} (\acrshort{mvc}) \cite{book-mvc}. Con este patrón se crea una separación de capas entre lo que es el Modelo, que contiene la representación de los datos y su persistencia, la Vista, que es la interfaz de usuario, y el Controlador, como intermediario entre el Modelo y la Vista.

Una aplicación estándar en \textit{Flask} incluye los siguientes ficheros:
\begin{itemize}
	\item \textbf{models.py}: representación del modelo de datos (Modelo).
	\item \textbf{templates}: carpeta con las plantillas HTML para la generación de páginas web (Vista).
	\item \textbf{routes.py}: rutas de acceso a la aplicación (Controlador).
	\item \textbf{\_\_init\_\_.py}: inicialización de la aplicación y librerías.
	\item \textbf{forms.py}: formularios y validación.
\end{itemize}

Además, otra buena práctica consiste en separar las aplicaciones en módulos para añadir extensibilidad mediante reglas, nuevas vistas, separación de roles y otros beneficios añadidos mediante el uso de \foreign{english}{blueprints}~\cite{book-mastering-flask}, una funcionalidad incluida en \textit{Flask}.

De esta forma se ha optado por crear los siguientes módulos o \foreign{english}{blueprints}, todos estos dentro del directorio \textbf{app}:

\begin{itemize}
    \item \textbf{account}: apartado de ``mi cuenta`` de un usuario.
    \item \textbf{admin}: panel de control del administrador, solo accesible para usuarios con ese rol.
	\item \textbf{base}: contiene la definición de Modelos y plantillas base.
    \item \textbf{data}: importación de datos de ejemplo.
    \item \textbf{home}: \foreignlanguage{english}{dashboard} de usuario.
\end{itemize}

Si se lista el directorio \textbf{app} se puede ver cómo cada módulo contiene una estructura de datos similar, siguiendo el estándar descrito previamente.

\begin{lstlisting}[style=ascii-tree]
$ tree -L 2 app/
app/
├── __init__.py
├── account
			├── __init__.py
			├── forms.py
			├── routes.py
			└── templates
├── admin
			├── __init__.py
			├── forms.py
			├── routes.py
			└── templates
├── base
			├── __init__.py
			├── forms.py
			├── models.py
...
\end{lstlisting}

\section{Sistema de Colas  interno}

Como se vio previamente, \textit{Pizarra} tiene un sistema de \Gls{cola}s interno. Esto se debe a varios motivos de peso. En primer lugar, se quiere establecer una separación de roles entre la aplicación web con la que los usuarios interactúan y la ejecución de código fuente. \textit{Pizarra} debe estar preparada para encolar tareas en el cluster \kahan del \acrshort{dsic}, pero otra de las posibilidades es la disponibilidad de poder hacerlo de forma local para cualquier otra persona que quiera hacer uso del aplicativo. \textit{Tablón}, el software en el cuál nos hemos inspirado, también ofrece ejecución local, pero con ciertas limitaciones, siendo una de ellas la obligación de reiniciar la aplicación cada 60 minutos~\cite{link-tablon-faq}:

\begin{quote}
    \textit{
    <<El servidor tablón está configurado para reiniciarse cada cierto tiempo. De está forma se eliminan trabajos erróneos y se eliminan las peticiones http no completadas. El tiempo que resta hasta el próximo reinicio se muestra en la página principal>>.}
\end{quote}

Además, una ejecución local desde el mismo aplicativo obliga a brindarle los recursos necesarios, ya sean procesadores (\acrshort{cpu}s) o memoria (\acrshort{ram}). Esto no es muy eficiente, ya que las aplicaciones en \textit{python}, y especialmente en \textit{Flask}, consumen muy pocos recursos. Por eso mismo, este aplicativo se puede ejecutar en dos modos diferentes:
\begin{itemize}
	\item \textbf{Modo \textit{Pizarra}}: aplicación web con la que interactúan los usuarios.
	\item \textbf{Modo \textit{Worker}}: un proceso que se encarga de revisar en las \gls{cola}s internas si hay \foreign{english}{jobs} a procesar.
\end{itemize}

La elección por la cual se han escogido dos modos diferentes de ejecución de la aplicación en contraposición a la creación de diferentes \textit{scripts} es para poder hacer uso de la misma definición de contenedor en \textit{Docker}, una estrategia habitual al utilizar esta solución \cite{link-sharing-docker-containers}.

Por último, otro beneficio que brinda esta separación de roles consiste en que se pueden ejecutar un número indefinido de \foreign{english}{Workers}, donde cada uno de ellos puede tener diferentes colas configuradas y unos recursos disponibles exclusivos.

\chapter{Desarrollo de la solución}

En este capítulo presentamos un resumen de cómo se ha pasado del diseño de la aplicación al producto final dando un repaso de cómo se ha abordado el desarrollo de los aspectos más relevantes como el \gls{envio} de \gls{tarea}s, el motor de reglas y el autómata creado para el proceso de tareas en diferentes tipos de \gls{cola}s. Esto no podría ser posible sin describir el listado completo de librerías necesarias y el sistema de plantillas que se utiliza para generar el contenido web. Por último, se presenta un resumen de los entregables que se fueron generando para dar vida al producto final.

\section{Flask \foreign{english}{boilerplate}}

La usabilidad es uno de los aspectos más importantes de una aplicación web y, en este caso, no se puede dejar de lado. Un \textit{usuario} de \textit{Pizarra} esperará una interfaz intuitiva y fácil de utilizar que le facilite el proceso de envío de soluciones (\foreign{english}{Requests}) a los problemas propuestos (\foreign{english}{Assignments}). No queremos que la aplicación se interponga entre el proceso de aprendizaje y la satisfacción de participar y obtener logros (\foreign{english}{Badges}). Una gran cantidad de aplicaciones utilizan las mismas librerías para maquetar los sitios web. Entre estas librerías, la más importante es \textit{Bootstrap}\footnote{Sitio web Bootstrap: \url{https://getbootstrap.com/}.} y, además, alrededor de estas librerías existen \foreign{english}{Dashboards} o Paneles de Control de código abierto para utilizar como punto de partida en nuevas aplicaciones.
	
Este conjunto de librerías y plantillas HTML tienen el nombre de \foreign{english}{boilerplate} y aceleran el desarrollo de una aplicación web tanto para usuarios noveles como también para usuarios expertos, ya que solo deben preocuparse de reutilizar componentes ya predefinidos.

Después de una búsqueda y pruebas de varias alternativas se ha optado por \textit{AdminLTE}\footnote{Sitio web AdminLTE: \url{https://adminlte.io/}.} (Figura~\ref{figura:admin-lte}) dada su variedad de plantillas disponibles, uso de otras librerías con amplia documentación y un aspecto visual amigable y moderno.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.70\textwidth]{img/admin-lte}
    \caption[AdminLTE: plantilla de Panel de Control ]{AdminLTE: plantilla de Panel de Control.}
	\label{figura:admin-lte}
\end{figure}

\section{Paquetes de Python}

Para dar funcionalidades adicionales en \textit{python}, normalmente se utilizan librerías o \Gls{paquete}s externos que simplifican y aceleran el desarrollo de la aplicación. A continuación se presenta un repaso de las librerías que son necesarias para \textit{Pizarra}. Este listado se encuentra disponible en el fichero \textbf{requirements.txt}, un estándar utilizado por desarrolladores y proveedores de servicios de \textit{hosting}~\cite{book-developing-web-python} para su fácil instalación a posteriori por administradores de paquetes de \textit{python}, como \textit{pip}\footnote{Sitio web pip: \url{https://pip.pypa.io/en/stable/}.}.

Un sistema de administración de paquetes es un \foreign{english}{software} que se encarga de resolver las referencias en un repositorio central, de su descarga y de su instalación de forma segura.

\subsection{Flask}

Este es el framework base de la aplicación, junto con otros \Gls{paquete}s adicionales que dan soporte a ciertas funcionalidades no incluidas en la librería base:

\begin{itemize}
	\item \textbf{flask}: framework base.
	\item \textbf{flask\_login}: funcionalidades extras para el manejo de sesiones de \textit{usuario}.
	\item \textbf{flask\_security}: uso de roles en el sistema.
	\item \textbf{flask\_wtf}: validación de formularios web.
	\item \textbf{flask\_sqlalchemy}: soporte a SQLAlchemy para el mapeo objeto-relacional a diferentes \acrshort{bd}.
	\item \textbf{flask\_migrate}: migración de base de datos basadas en SQLAlchemy.
	\item \textbf{flask-babel}: localización de la aplicación en diferentes idiomas.
	\item \textbf{email-validator}: validación de correos electrónicos para la librería wtf.
\end{itemize}

\subsection{Sistemas de Colas}

Paquetes para el  funcionamiento del Sistema de \gls{cola}s interno y conectividad con \textit{Redis}:

\begin{itemize}
	\item \textbf{rq}: librería de Redis Queue (\textit{RQ}).
	\item \textbf{rq-dashboard}: visualización web del estado de \foreign{english}{queues} y \foreign{english}{jobs}.
	\item \textbf{redis}: soporte y conectividad al servicio de \textit{Redis}.
\end{itemize}

\subsection{Conexión con sistemas externos}

Para poder utilizar las \Gls{cola}s de \kahan es necesario poder conectarnos vía protocolos seguros, ya sea para ejecutar comandos o para copiar ficheros, para cada uno de ellos son necesarios:

\begin{itemize}
	\item \textbf{paramiko}: soporte de protocolo \acrfull{ssh}\footnote{Sitio web SSH: \url{https://tools.ietf.org/html/rfc4253}}.
	\item \textbf{scp}: soporte de protocolo \acrfull{scp}\footnote{Sitio web SCP: \url{https://datatracker.ietf.org/doc/draft-evans-v2-scp/}}.
\end{itemize}

\subsection{Datos de ejemplo}

Para facilitar el desarrollo y su posterior mantenimiento se debe poder disponer de una forma fácil y estandarizada de carga de datos de ejemplo. Para esta funcionalidad se ha optado por ficheros en formato \textit{yaml}. Los \gls{paquete}s que añaden este soporte son:

\begin{itemize}
    \item \textbf{pyyaml}: analizador de ficheros \textit{yaml}.
	\item \textbf{sqla-yaml-fixtures}: definición de datos via \textit{yaml}, transformación a objetos e importación a la \acrshort{bd} con \textit{SQLAlchemy}.
\end{itemize}

\subsection{Otros Paquetes}

Además, hay algunas funcionalidad específicas que requieren el uso de las siguientes librerías:

\begin{itemize}
	\item \textbf{gunicorn}: ejecución y monitoreo de la aplicación.
	\item \textbf{lizard}: analizador de código estático.
	\item \textbf{rule\_engine}: evaluador de reglas con expresiones lógicas, utilizado para asignar \Gls{insignia}s.
\end{itemize}


\section{Envío de soluciones a Tareas}

Cuando un \Gls{alumno} realiza un \Gls{envio}, esto es, una petición web que incluye el código fuente a compilar y ejecutar como propuesta de solución a una \Gls{tarea}, la aplicación debe procesar la petición. El \Gls{envio} pasa por una serie de verificaciones que se describen a continuación, algunas de las cuáles no se realizan para un usuario con rol de \gls{administrador} del sistema:

\begin{enumerate}
	\item Se autentifica al usuario.
	\item Se busca la \Gls{tarea} en la \Gls{bd}.
	\item La \Gls{tarea} debe estar abierta a recibir \Gls{envio}s.
	\item El \Gls{alumno} pertenece a un \Gls{grupo} que la tenga asignada.
	\item El \Gls{alumno} no ha enviado peticiones muy rápido.
	\item El \Gls{alumno} tiene Quota (tiempo disponible de ejecución) para procesar el \Gls{envio}.
	\item El \Gls{envio} contiene un fichero a procesar.
	\item El fichero a procesar con el código fuente no contiene código malicioso.
\end{enumerate}

Si alguno de los pasos anteriores no pasa uno de los puntos de verificación se devuelve un mensaje de error con el código HTTP correspondiente. En el caso de que todas los chequeos sean satisfactorios se crea un objeto de tipo \textit{Request} en la \acrshort{bd} y otro de tipo \foreign{english}{job} para la \Gls{cola} interna en \textit{Redis}.

El \Gls{envio} de una \Gls{tarea} se realiza desde un terminal de comandos u otro cliente que permita realizar peticiones web como \textit{Postman}\footnote{Sitio web Postman: \url{https://www.postman.com/}.}, y está construida para devolver respuestas en formato JSON, que es un estándar utilizado en muchas aplicaciones web cuando se diseña una \acrshort{api}. Un \Gls{envio} contiene como parámetros el usuario, el token de acceso, un fichero con el código fuente y la URL de la \Gls{tarea}. Al procesarse la petición se recibe la respuesta.

En el siguiente código se muestran tres ejemplos: 1) una autentificación fallida, 2) un \gls{envio} satisfactorio, y 3) un \Gls{envio} no procesado porque el usuario debe esperar un tiempo. \newline

\begin{lstlisting}[style=ascii-tree]
$ curl -k -X POST -F 'file=@primos.c' http://foo:bar@127.0.0.1:5000/assignments/primos
{
"code": 401,
"message": "Authentication failed"
}
$ curl -k -X POST -F 'file=@primos.c' http://foo:gB8HSgWhfg@127.0.0.1:5000/assignments/primos
{
"code": 201,
"message": "Request created, please navigate to http://127.0.0.1:5000/requests/13 to check the results"
}
$ curl -k -X POST -F 'file=@primos.c' http://foo:gB8HSgWhfg@127.0.0.1:5000/assignments/primos
{
"code": 403,
"message": "You are sending Requests too fast. Time between Requests is 60 seconds"
}
\end{lstlisting}

El diagrama de flujo de una petición web para un \gls{envio} es el que se ve en la Figura~\ref{figura:request-flowchart}.

\begin{figure}[!t]
	\centering
	\includegraphics[width=0.8\textwidth]{img/request-flowchart}
    \caption[Diagrama de flujo de una petición web para un Envío]{Diagrama de flujo de una petición web para un Envío.}
	\label{figura:request-flowchart}
\end{figure}

\FloatBarrier

\section{Ejecución en una Cola interna}

Previamente se ha hablado de que el \gls{paquete} \textit{RQ} permite simular un \textit{Administrador de Tareas} con el uso de una \gls{cola} interna de ``trabajos'' o \foreign{english}{jobs} ejecutados por unos \foreign{english}{Workers}, aunque ha faltado explicar el cómo. Primero, vamos a presentar las dos clases que proporciona \textit{RQ}; 1) \foreign{english}{Worker} y 2) \foreign{english}{Queue}, y cómo son utilizadas por \textit{Pizarra}.

En el siguiente ejemplo podemos ver la creación de un ``trabajador'' o \foreign{english}{Worker} al iniciar \textit{Pizarra} en este modo. \newline

\begin{code}{app/\_\_init.py\_\_}
...
redis_url = app.config["RQ_DASHBOARD_REDIS_URL"]
redis_connection = redis.from_url(redis_url)
with Connection(redis_connection):
	worker = Worker(app.config['QUEUES'])
	worker.work(with_scheduler=True)
...
\end{code}

El extracto de código del fichero \textbf{app/\_\_init.py\_\_} realiza el siguiente trabajo:

\begin{enumerate}
	\item Lee de la configuración de \textit{Pizarra} la URL del servicio de \textit{Redis}.
	\item Crea una conexión con el servicio de \textit{Redis}.
	\item Crea un Objeto de tipo \foreign{english}{Worker} con las \gls{cola}s disponibles.
	\item Pone el \foreign{english}{Worker} a ``trabajar'' revisando el servicio de \textit{Redis} periodicamente para ver si hay \foreign{english}{jobs} a ejecutar.
\end{enumerate}

El próximo paso es ver cómo se crean los \foreign{english}{jobs} que, en el caso de nuestra aplicación, serán las \textit{Requests} o \gls{envio}s de los \textit{usuarios} a procesar por los \foreign{english}{Workers}. Para esta funcionalidad tenemos dos métodos en el fichero \textbf{app/base/models\_jobs.py} \newline

\begin{code}{app/base/models\_jobs.py}
...
def process_job(job):
	"""
	process a given job
	"""
	job.process()

def create_job(user_request) -> str:
	"""
	creates and enqueues a job from pizarra to be executed by a worker and returns job id
	"""
	with Connection(redis.from_url(current_app.config["RQ_DASHBOARD_REDIS_URL"])):
	q = Queue(name=user_request.assignment.queue)
	rq_job = q.enqueue(process_job, LocalJob(user_request))
	return rq_job.get_id()
...
\end{code}

El método \textit{create\_job} recibe como parámetro un \textit{Request}, donde su definición no es relevante, salvo que se utilizará para el \textit{job} a procesar y, además, tiene el nombre de la \foreign{english}{Queue} interna donde debe encolarse. Realiza lo siguiente:

\begin{enumerate}
	\item Abre una conexión con el servicio de \textit{Redis}.
	\item Crea un objeto de tipo \foreign{english}{Queue} con el nombre de la \gls{cola} a utilizar.
	\item crea un \foreign{english}{job} utilizando el método \textit{process\_job}, que recibe como parámetro una clase genérica que debe tener implementado el método \textit{process}. Ese \foreign{english}{job} se inserta en la \foreign{english}{Queue}.
	\item Devuelve el ID del \foreign{english}{job} para poder asignarlo a la \textit{Request}.
\end{enumerate}

Por último, veo muy importante explicar la creación del siguiente autómata, ya que es la forma en la cual se ha podido resolver la ejecución en una \gls{cola} Local de \kahan así como en cualquier otra que se quiera utilizar en un futuro. El código presentado de la clase \textit{LocalJob} es una simplificación de la clase real de \textit{Pizarra}, donde se presentan los elementos básicos para dar el contexto de su funcionamiento.
Para facilitar la lectura se ha dividido el código fuente en tres recuadros, asumiendo que forman un solo código.

\begin{code}{app/base/models\_jobs.py}
class StepResult(enum.Enum):
	START = 0
	OK = 1
	NOK = 2
	WAIT = 3
	END = 4
	
class LocalJob:
	def __init__(self, user_request):
		...
		self.user_request = user_request
		self.task_process = {
			RequestStatus.CREATED: {
				'f': self.start,
				'steps': {
					StepResult.OK: RequestStatus.VERIFYING,
				}
			},
			RequestStatus.VERIFYING: {
				'f': self.verify,
				'steps': {
					StepResult.OK: RequestStatus.COMPILE,
					StepResult.NOK: RequestStatus.ERROR
				}
			}
			...
		}
	
\end{code}

Este autómata tiene una serie de etiquetas que ayudarán a saber a qué estado se debe pasar a continuación (\foreign{english}{StepResult}). Al crear un objeto del tipo \textit{LocalJob} en esta versión simplificada se puede ver cómo se asigna el \foreign{english}{Request} y, además, existe la definición del autómata como un mapa, donde para una etiqueta se asigna un método a ejecutar y un mapa de transiciones que depende del resultado de la ejecución del paso. \newline
	
\begin{code}{app/base/models\_jobs.py}
	def get_task_step(self):
		return self.task_process[self.user_request.status]
	
	def is_job_completed(self):
		return self.user_request.status in [RequestStatus.CANCELED, RequestStatus.ERROR, RequestStatus.TIMEWALL,
		RequestStatus.FINISHED, RequestStatus.UNHANDLED_ERROR]
\end{code}

La función \textit{get\_task\_step} devuelve el método para el paso en el que se encuentra el autómata y el atributo dinámico \textit{is\_job\_completed} verifica si el proceso ha terminado. \newline 

\begin{code}{app/base/models\_jobs.py}
	def process(self):
		"""
		process the task request step by step until the task is enqueued again or it finishes
		"""
		step_result = StepResult.OK
		while step_result != StepResult.END:
			step = self.get_task_step()
			f = step['f']
			step_result = f()
			
			if step_result == StepResult.WAIT:
				requeue_job(self)
				break
				
			self.update_request(step['steps'][step_result])
	
	def start(self):
		return StepResult.OK
	
	def verify(self):
		return StepResult.OK if (
	self.__not_contains_malicious_content() and self.__static_code_analysis()) else StepResult.NOK
\end{code}

En el tercer bloque se encuentra la función \textit{process} que, como explicamos previamente, es el método que ejecuta el \foreign{english}{Worker} al obtener un \foreign{english}{job} de una \gls{cola}. Obtiene el estado actual de la \foreign{english}{Request} y lleva a cabo el siguiente proceso hasta terminar:

\begin{enumerate}
	\item Obtener la función.
	\item Ejecutar la función y asignar el resultado al estado actual.
    \item Si el resultado es \textit{WAIT}, vuelve a encolar la tarea para ejecutarla en un futuro. Esto se realiza para \gls{cola}s como la de \kahan, donde debemos revisar el estado de una ejecución cada cierto periodo de tiempo.
    \item Se actualiza el estado de la \textit{Request}, donde el nuevo estado se obtiene del mapa \textit{steps} del resultado del paso.
\end{enumerate}

Como se puede ver en el método de ejemplo \textit{start} se devolverá un OK y el nuevo estado de la \textit{Request} será \textit{VERIFYING}. En el próximo paso ejecutará el método \textit{verify} que llama a dos métodos adicionales que verifican que no haya código malicioso y realiza el análisis del código estático; y así hasta terminar la ejecución.

Gracias a este simple pero efectivo autómata se podrá extender la aplicación para que soporte otros tipos de \gls{cola}, tal como se verá más adelante en el Capitulo 9 dedicado a la Extensibilidad del software desarrollado.

\section{Asignación de Insignias}

Cuando se llegó a la etapa de desarrollo en la cuál se tenían que crear las \gls{insignia}s (\foreign{english}{Badges}) se encontró un problema de gran dificultad. ¿Cómo permitir que un \gls{administrador}, desde su panel web, pueda hacer que una \gls{insignia} se aplique cuando suceda algo en particular? Las \gls{insignia}s no solo se obtienen al completar una \gls{tarea} de forma correcta, sino que también pueden obtenerse en otros casos como, por ejemplo, que el \gls{envio} se encuentre en los primeros tres puestos de la tabla de posiciones (\foreign{english}{leaderboard}).

La primera opción, que posteriormente fue descartada, fue crear una clase en \textit{python} por cada tipo de \gls{insignia} que se quería asignar a un \gls{alumno}. Esto quitaba dinamismo y forzaba al \gls{administrador} a modificar el código fuente de la aplicación, algo que quería evitarse ya que impone una barrera de entrada a cualquier persona que quiera hacer uso de \textit{Pizarra} en un futuro.

Después de investigar otras posibilidades y realizar una serie de pruebas se optó por añadir el \gls{paquete} \textit{rule\_engine} que permite la creación de objetos de tipo ``Rule''. Estos objetos pueden ser evaluados con expresiones lógicas que son escritas como cadenas de texto y pueden guardarse en una columna de la \acrshort{bd} como atributo de la clase \foreign{english}{Badge}. \textit{rule\_engine} no es la única librería que añade este tipo de funcionalidad en \textit{python} pero su simplicidad y el soporte de \textit{Data objects} \cite{link-rule-engine}, que es la representación de una clase en formato \acrshort{json}, fueron dos razones por las cuáles se optó por esta solución.

Con la posibilidad de escribir reglas como cadenas de texto y sabiendo que un \foreign{english}{job} tiene los atributos \textit{user, request, assignment} y \textit{leaderboard} como diccionarios de \textit{python}, podemos crear \foreign{english}{Badges} como las que se encuentran en los datos de ejemplos del fichero \textbf{sample.yml}. \newline

\begin{code}{app/data/sample.py}
- Badge:
	- name: "beat_the_machine"
	description: "Earn when your program runs below a certain threshold"
	rule: "request.run_time < 10"
	- name: "leader"
	description: "Earn when your Request is in the first positions of the leaderboard"
	rule: "leaderboard.position <= 3"
\end{code}

En el ejemplo mostrado en \textbf{sample.yml} podemos observar la creación de dos \gls{insignia}s que se asignarán a un \gls{alumno} cuando la ejecución de su programa tarde menos de 10 segundos, y también otro caso donde la posición de la ejecución quede entre las tres mejores. La descripción de los atributos es:

\begin{itemize}
	\item \textbf{name}: ID único de la \gls{insignia}.
	\item \textbf{description}: descripción que se mostrará a los \textit{usuarios} del sistema.
	\item \textbf{rule}: regla que se comprobará al terminar la ejecución.
\end{itemize}

El sistema de reglas expuesto dará pie a la creación de algunas \gls{insignia}s especiales como, por ejemplo, una primera ejecución correcta en el \foreign{english}{cluster}, haber agotado el tiempo de ejecución al recibir un TIMEWALL, que el ID del \textit{Request} sea un número especial como el 1000 y otras.

\section{Entregables}

Dado que la creación de la aplicación ha sido elaborada dentro de un marco de Desarrollo Ágil, cada entregable ha presentado una serie de nuevas funcionalidades hasta llegar al producto final. Mediante el siguiente resumen de las versiones se puede ver cómo, partiendo de unos cimientos, ha ido evolucionando el \foreign{english}{software} hasta su estado actual.

\begin{itemize}
	\item \textbf{Versión 0.1}
	\begin{itemize}
		\item \textbf{fecha entrega}: 8 de Abril.
		\item \textbf{resumen}: registro e ingreso de \textit{usuarios} con visualización de página de inicio.
		\item \textbf{requisitos funcionales}: RF-1, RF-2 y RF-4.
	\end{itemize}
	\item \textbf{Version 0.2}
	\begin{itemize}
		\item \textbf{fecha entrega}: 22 de Abril.
		\item \textbf{resumen}: envío de código, análisis estático y procesamiento. Visualización de \gls{tarea}s. Creación de equipos.
		\item \textbf{requisitos funcionales}: RF-3, RF-7, RF-8 y RF-9.
	\end{itemize}
	\item \textbf{Version 0.3}
\begin{itemize}
	\item \textbf{fecha entrega}: 29 de Abril.
	\item \textbf{resumen}: asignación de \gls{insignia}s y visualización de \gls{envio}s.
	\item \textbf{requisitos funcionales}: RF-5, RF-6 y RF-12.
\end{itemize}
	\item \textbf{Version 0.4}
\begin{itemize}
	\item \textbf{fecha entrega}: 7 de Mayo.
	\item \textbf{resumen}: panel de administración.
    \item \textbf{requisitos funcionales}: RF-13, RF-14, RF-15, RF-16, RF-17, RF-18.
\end{itemize}
	\item \textbf{Version 0.5}
\begin{itemize}
	\item \textbf{fecha entrega}: 13 de Mayo.
	\item \textbf{resumen}: Equipos. Creación y edición de \gls{tarea}s. Ejecución en \kahan.
	\item \textbf{requisitos funcionales}: RF-3 y RF-19.
\end{itemize}
	\item \textbf{Version 0.6}
\begin{itemize}
	\item \textbf{fecha entrega}: 20 de Mayo.
	\item \textbf{resumen}: FAQ y Perfil. 
	\item \textbf{requisitos funcionales}: RF-11 y RF-20.
\end{itemize}
	\item \textbf{Version 1.0}
\begin{itemize}
	\item \textbf{fecha entrega}: 27 de Mayo.
	\item \textbf{resumen}: versión final con correcciones menores y despliegue en la nube.
\end{itemize}	
\end{itemize}

\chapter{Implantación}

\textit{Pizarra} es una herramienta que necesita de otros aplicativos para su funcionamiento: una \acrfull{bd}, \textit{Redis} para el sistema de \gls{cola}s interno de envío de \gls{tarea}s, un \acrshort{nfs} para compartir recursos y \textit{Nginx} para actuar como servidor web y redirigir las peticiones. 

En el pasado, la implantación hubiera requerido la intervención del equipo de Administración de Sistemas para instalar el \textit{SO} de cada máquina, crear usuarios, asignar permisos, abrir puertos y otro sinfín de tareas. Hoy en día es diferente.
Para evitar tener que realizar todos estos pasos y acelerar la puesta en producción el proyecto incluye la posibilidad de que todos los elementos de la arquitectura se desplieguen en \Gls{contenedor}es. Estos \Gls{contenedor}es están creados con la tecnología \textit{Docker} y son paquetes que incluyen todo lo necesario, ya sean librerías u otras herramientas del sistema necesarias para que el software se ejecute.

\textit{Docker} ofrece una funcionalidad similar a la de una \acrfull{vm}, siendo algo bastante diferente. En primer lugar no es necesario asignar recursos físicos a cada \gls{contenedor} ya que es el mismo \textit{Docker Engine} (servicio) el que se encarga de asignarlos de forma dinámica (Figura~\ref{figura:container-vs-vm}) y esto hace que se aproveche mejor el \foreign{english}{hardware}; además tienen una huella en espacio en disco mucho menor que el tradicional \acrshort{so} con todos las librerías y servicios que vienen preinstalados ya que solo contienen lo esencial para su funcionamiento. Como ejemplo, el \gls{contenedor} de \textit{Redis} que utilizamos ocupa 29.8 \acrshort{mb} cuando una \acrshort{vm} con el mismo servicio pueden llegar a ser varios Gigabytes.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.65\textwidth]{img/container-vs-vm}
	\caption[Diferencias entre \textit{Docker} y máquina virtual]{Diferencias entre \textit{Docker} y máquina virtual}
	\label{figura:container-vs-vm}
\end{figure}

\section{Docker y Kubernetes}

Para nuestro entorno de desarrollo local utilizamos \gls{contenedor}es públicos como el de \textit{PostgreSQL} que, con un fichero de configuración, permite tener el servicio ejecutándose en cuestión de minutos. A continuación, se muestra un extracto del fichero \textbf{docker-compose.yaml} del repositorio: 
\newline

\begin{code}{docker-compose.yml}
version: "3.1"
services:
  postgres:
    image: postgres: 9.6-alpine
    container_name: postgres
    volumes:
      - /data/pizarra/postgres:/var/lib/postgresql/data
    ports:
      - 5432: 5432
    environment:
      - POSTGRES_USER=pizarra
      - POSTGRES_PASSWORD=pizarra
    restart: unless-stopped
...
\end{code}

Los parámetros tienen el siguiente uso: 
\begin{itemize}
	\item \textbf{version}: versión de la API de \textit{Docker}.
	\item \textbf{services}: listado de servicios a desplegar.
    \item \textbf{image}: \gls{contenedor} oficial de \textit{PostgreSQL}\footnote{Postgres Official Docker Image: \url{https://hub.docker.com/_/postgres}.} sobre Linux Alpine.
	\item \textbf{container\_name}: nombre que se le dará al \gls{contenedor} al iniciarse.
	\item \textbf{volumes}: mapeo de directorios de nuestro entorno de desarrollo local al \gls{contenedor}. Esto se hace para evitar perder la información de la \acrshort{bd} ya que los \gls{contenedor}es son \foreignlanguage{english}{stateless} (no mantienen un estado y al reiniciarse o eliminarse se pierde toda la información).
    \item \textbf{ports}: mapeo de puertos del \acrshort{so} a los \gls{contenedor}es, esto permite acceder al servicio de \textit{PostgreSQL} por un puerto local.
    \item \textbf{environment}: variables de entorno del \acrshort{so}, en este caso se define un usuario y una contraseña para acceder a la \acrshort{bd}.
    \item \textbf{restart}: con el parámetro \foreignlanguage{english}{unless-stopped} nuestro \gls{contenedor} se reiniciará de forma automática en caso de errores, a menos que se envíe un mensaje de finalización de ejecución.
\end{itemize}

Con los parámetros previos y siguiendo la documentación de variables de entorno disponibles, al iniciarse el \gls{contenedor} se crearán los \foreignlanguage{english}{schemas} y directorios necesarios en caso de que no existan y un usuario con privilegios con el nombre y contraseña proporcionados.

Para un entorno de desarrollo local y/o de pruebas \textit{Docker} puede ser una herramienta que cumpla con nuestras necesidades, pero para un entorno de producción es necesario contar con un servicio que realice la implantación de forma automatizada, que sea eficiente en el manejo de recursos y resiliente en caso de problemas. Para esta tarea utilizaremos \textit{Kubernetes}, un \textit{orquestador} de \gls{contenedor}es que permite auto escalado de aplicaciones, automatización de despliegues y configuración de forma declarativa.

\section{Despliegue en la Nube con Kubernetes}

Existe ciertas limitaciones en \foreign{english}{cluster} \kahan que han impedido la instalación del servicio de \textit{Kubernetes} (K8s). Este era uno de los riesgos contemplados en el trabajo. Para resolver este problema se ha optado por un despliegue de \textit{Pizarra} en la nube. 

Existen varios proveedores de \textit{K8s} en Internet (puede consultarse el listado de todos los \foreign{english}{partners} en el sitio oficial de \textit{Kubernetes}\footnote{Kubernetes - Partners: \url{https://kubernetes.io/es/partners}.}) siendo los más importantes: Google Cloud Engine (\textit{GCE}), Amazon Web Services (\textit{AWS}) y Microsoft Azure. Se ha optado por desplegar la aplicación en \textit{GCE}, ya que dispone de buena documentación y, además, \textdollar 300 de crédito promocional, que es más que suficiente para tener el aplicativo funcionando durante meses.

\subsection{Pasos de un despliegue en GCE}

En primer lugar debemos crear una cuenta en Google o utilizar una existente que nunca ha activado \textit{GCE} de forma previa ya que el crédito promocional de bienvenida tiene una caducidad de 12 meses desde la activación.

Con nuestra cuenta accedemos a la Consola Web de \acrshort{gce} y creamos nuestro proyecto, en este caso lo llamaremos ``Pizarra'' (Figura~\ref{figura:gce-new-project}). Nuestro aplicativo utiliza \textit{Kubernetes Engine} y el \textit{Container Registry} que son visibles desde el menú lateral. Entraremos a cada uno de ellos para habilitar su \acrshort{api}.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.55\textwidth]{img/gce-new-project}
	\caption[nuevo proyecto en GCE]{Creación de un nuevo proyecto en Google Cloud Engine.}
	\label{figura:gce-new-project}
\end{figure}

Una vez creado el proyecto y habilitadas las \acrshort{api}'s hay que descargar\footnote{Cómo instalar el SDK de Google Cloud: \url{https://cloud.google.com/sdk/install?hl=es-419}.} e inicializar\footnote{Cómo inicializar el SDK de Cloud:  \url{https://cloud.google.com/sdk/docs/initializing?hl=es-419}.} Google Cloud SDK para hacer uso de la consola de comandos de forma local. 

Todos los pasos descritos a continuación se ejecutan de forma automática con un script\footnote{Script Despliegue \acrshort{gce}: \url{https://github.com/nimar3/pizarra/blob/master/gce/commands.sh}.} incluido en el repositorio de código. Lo único que se necesita de forma previa es la configuración de algunos parámetros de despliegue como variables de entorno del \acrshort{so} donde se ejecuta.
Las variables de entorno necesarias son el ID del proyecto en \acrshort{gce} y las credenciales de la \acrshort{bd} que serán guardados como un secreto en \textit{Kubernetes}. Podemos exportarlas antes de lanzar nuestro script ejecutando los siguientes comandos en la consola:
\begin{lstlisting}[style=ascii-tree]
$ export PROJECT_ID=pizarra-id
$ export DB_USERNAME=pizarra
$ export DB_PASSWORD=pizarra
\end{lstlisting}

Estas son las lineas que ejecuta el \textit{script}, donde todos los ficheros que forman parte de cada comando se encuentran en el repositorio\footnote{Ficheros de despliegue en \acrshort{gce}: \url{https://github.com/nimar3/pizarra/tree/master/gce}.}: 

\begin{enumerate}
	
	\item Establecimiento del proyecto y zona geográfica donde desplegaremos el aplicativo. Por cercanía geográfica se ha escogido el centro de datos de Países Bajos.
	
	\begin{lstlisting}[style=ascii-tree]
	$ gcloud config set project ${PROJECT_ID}
	$ gcloud config set compute/zone europe-west4
	\end{lstlisting}
	
\item Credenciales para la \acrshort{bd} para ser obtenidas a posterior por los contenedores de \textit{Kubernetes}.
	
	\begin{lstlisting}[style=ascii-tree]
	$ kubectl create secret generic pizarra-credentials \
	--from-literal db_username=${DB_USERNAME} \
	--from-literal db_password=${DB_PASSWORD}
	\end{lstlisting}
	
	\item Subida de \Gls{contenedor}es de \textit{Nginx} y \textit{Pizarra} al Registro de \acrshort{gce}. Los otros \Gls{contenedor}es utilizarán imágenes públicas.
	
	\begin{lstlisting}[style=ascii-tree]
	$ docker push eu.gcr.io/${PROJECT_ID}/pizarra
	$ docker push eu.gcr.io/${PROJECT_ID}/nginx
	\end{lstlisting}
	
	\item Creación de \foreign{english} en \textit{Kubernetes} con 2 nodos. Una vez creado se descargan las credenciales para trabajar con él.

	\begin{lstlisting}[style=ascii-tree]	
	$ gcloud container clusters create pizarra --num-nodes=2
	$ gcloud container clusters get-credentials pizarra
	\end{lstlisting}

	\item Creación de Almacenamiento de 10 \acrshort{gib} para la persistencia de datos que será utilizado por el \acrshort{nfs}. Replicado en varias zonas ya que el almacenamiento no es parte de \textit{Kubernetes Engine}.
	
	\begin{lstlisting}[style=ascii-tree]
	$ kubectl apply -f storage.yaml
	\end{lstlisting}
	
\item Creación del servicio de \acrfull{nfs}.
	
	\begin{lstlisting}[style=ascii-tree]
	$ kubectl apply -f nfs.yaml
	\end{lstlisting}
	
\item Creación del servicio de Redis para el sistema de colas local.
	
	\begin{lstlisting}[style=ascii-tree]
	$ kubectl apply -f redis.yaml
	\end{lstlisting}
	
\item Creación del servicio de \acrlong{bd}.
	
	\begin{lstlisting}[style=ascii-tree]
	$ kubectl apply -f postgress.yaml
	\end{lstlisting}
	
\item Despliegue de \textit{Pizarra} y 1 \textit{Worker} que se encargará de encolar las las \Gls{tarea}s en \kahan.
	
	\begin{lstlisting}[style=ascii-tree]
	$ kubectl apply -f pizarra.yaml
	\end{lstlisting}
	
\item Despliegue del servicio de \textit{NGinx} con una IP pública para el acceso de usuarios por Internet.
	
	\begin{lstlisting}[style=ascii-tree]	
	$ kubectl apply -f nginx.yaml
	\end{lstlisting}
	
\end{enumerate}

Una vez completados todos los pasos se puede obtener la IP pública de Pizarra ejecutando el siguiente comando:

\begin{lstlisting}[style=ascii-tree]
$ kubectl get services
\end{lstlisting}

Con esto se ha completado el despliegue y ya podemos navegar a Pizarra para comenzar a \textit{interactuar} con el aplicativo.

\subsection{Costos asociados}

\acrshort{gce} cuenta con una herramienta\footnote{Calculadora de precios de Google: \url{https://cloud.google.com/products/calculator/}.} para estimar el gasto mensual en el que podemos incurrir con la utilización de los recursos contratados. Se ha realizado una estimación con los siguientes parámetros (Figura~\ref{figura:gce-estimated-cost}):

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.75\textwidth]{img/google-cloud-engine-cluster-cost}
	\caption[Calculadora de precios en GCE]{Configuración de la calculadora de precios para el despliegue en Kubernetes de Pizarra.}
	\label{figura:gce-estimated-cost}
\end{figure}

\begin{itemize}
	\item  Kubernetes:
	\begin{itemize}
        \item Número de nodos: 2.
        \item Tipo de Instancia: n1-standard-n1 (vCPUs: 1, RAM: 3.75 GB).
        \item Centro de Datos: Países Bajos.
	    \item Uso estipulado: 24 horas al día los 7 días a la semana.
	 \end{itemize}
    \item Persistencia:
	\begin{itemize}
        \item Tamaño disco: 10 GiB.
        \item Centro de Datos: Países Bajos.
    \end{itemize}
\end{itemize}

El número de nodos es 2 para tener servicio en caso de que haya una caída de uno de los nodos del \textit{cluster}, el centro de datos se ha escogido Países Bajos por cercanía geográfica y una instancia de tipo \textit{n1-standard-n1} que ofrece los recursos mínimos necesarios para los contenedores a lanzar. El disco es compartido entre la \acrshort{bd} y \textit{Pizarra} con suficiente margen para evitar problemas de espacio.

Utilizando la calculadora da un costo aproximado de \texteuro 49.00 mensuales. Como dato adicional, se puede variar de Centro de Datos y otros parámetros como el uso estipulado para reducir los costos aún más. Podemos guardar la estimación o enviárnosla por correo electrónico (Figura~\ref{figura:gce-estimated-cost-email}).

\begin{figure}
	\centering
	\includegraphics[width=0.70\textwidth]{img/google-cloud-engine-estimated-cost}
	\caption[Estimación de costos en GCE]{Ejemplo de correo de GCE con una estimación de los costos asociados por mes.}
	\label{figura:gce-estimated-cost-email}
\end{figure}

\chapter{Pruebas}

\chapter{Mantenimiento}

El desarrollo de \textit{software} es un proceso evolutivo y requiere de un mantenimiento continuo para asegurar el correcto funcionamiento, como así también la posibilidad de añadir mejoras y nuevas funcionalidades. Para poder asegurar este proceso tienen que cumplirse ciertas pautas como el acceso al código fuente, en este caso disponible en un repositorio de código abierto en Internet, una guía de como configurar un entorno de desarrollo local, el proceso a seguir para mantener un estándar de calidad en el código fuente y el manejo de versiones. Los siguientes apartados abordan todos estos puntos para cumplir con el proceso de mantenimiento de \textit{software}.

\section{Entorno local de desarrollo}

Para configurar un entorno de desarrollo local se debe cumplir los siguientes requisitos.

\begin{itemize}
    \item  Tener instalado \textit{python3}\footnote{Descarga oficial de Python: \url{https://www.python.org/downloads/}.} y \textit{Docker}\footnote{Descarga oficial de Docker: \url{https://docs.docker.com/get-docker/}.} en nuestra máquina
	\item Clonado el repositorio de \textit{Pizarra} realizando los siguientes pasos:
	\begin{enumerate}
		\item Creación de directorio para el proyecto
		\begin{lstlisting}[style=ascii-tree]
		$ mkdir pizarra
		$ cd pizarra/
		\end{lstlisting}
		\item Inicialización de un nuevo repositorio y añadida la dirección remota
		\begin{lstlisting}[style=ascii-tree]
		$ git init .
		Initialized empty Git repository in /Users/nmartini/pizarra/.git/
		$ git remote add upstream git@github.com:nimar3/pizarra.git
		\end{lstlisting}
		\item Descarga del código fuente
		\begin{lstlisting}[style=ascii-tree]
		$ git fetch upstream
		remote: Enumerating objects: 589, done.
		remote: Counting objects: 100% (589/589), done.
		remote: Compressing objects: 100% (364/364), done.
		remote: Total 6891 (delta 396), reused 393 (delta 221), pack-reused 6302
		Receiving objects: 100% (6891/6891), 19.14 MiB | 675.00 KiB/s, done.
		Resolving deltas: 100% (1748/1748), done.
		\end{lstlisting}
		\item \foreign{english}{checkout} a la rama donde se va a trabajar, en este caso \textit{master}
		\begin{lstlisting}[style=ascii-tree]
		$ git checkout master
		Checking out files: 100% (4858/4858), done.
		Branch 'master' set up to track remote branch 'master' from 'upstream'.
		Already on 'master'
		\end{lstlisting}
	\end{enumerate}
	\item Creación de un entorno virtual e instalación de todos los \Gls{paquete}s de \textit{python} necesarios.
	\begin{lstlisting}[style=ascii-tree]
	$ python3 -m venv env
	$ source env/bin/activate   
	(env) $ pip3 install -r requirements_dev.txt
	\end{lstlisting}
\end{itemize}

Si hemos realizado cambios en el código fuente se debe ejecutar el siguiente comando para generar una nueva versión de nuestro \Gls{contenedor} de \textit{Docker} de \textit{Pizarra}: \newline

\begin{lstlisting}[style=ascii-tree]
$ docker build -t pizarra .
\end{lstlisting}

Por último, para iniciar \textit{Pizarra} con todos los componentes introducimos el siguiente comando en la raíz del repositorio. Todos los componentes deben mostrar que se han creado correctamente con el mensaje \textit{done}. \newline

\begin{lstlisting}[style=ascii-tree]
(env) $ docker-compose up
Creating network "pizarra_default" with the default driver
Creating redis    ... done
Creating postgres ... done
Creating pizarra  ... done
Creating worker   ... done
Creating nginx    ... done
\end{lstlisting}

\begin{wrapfigure}{r}{0.25\textwidth}
	\includegraphics[width=0.25\textwidth]{img/docker-compose-pizarra}
	\caption[Inicio de sesión en Pizarra]{Inicio de sesión en Pizarra.}
	\label{figura:docker-compose-pizarra}
\end{wrapfigure}

Se puede acceder a la aplicación web navegando a la URL https://127.0.0.1/ y se redirigirá automáticamente al inicio de sesión (Figura\ref{figura:docker-compose-pizarra})

En algunos casos sólo es necesario la ejecución del aplicativo web con una \acrshort{bd} local en SQLite para hacer pruebas sobre cambios que no afectan otros componentes. Con este tipo de ejecución solo se podrá acceder a la aplicación web sin ningún \textit{Worker} o el servicio de \textit{Redis}, en resumen, se está ejecutando solamente el \textit{script} de la aplicación en \textit{Flask} y será útil para visualizar modificaciones a nivel visual.

Esto se puede hacer utilizando el siguiente comando y \textit{Pizarra} estará disponible en la URL http://127.0.0.1:5000/ (el puerto por defecto de \textit{Flask} es el 5000). \newline

\begin{lstlisting}[style=ascii-tree]
(env) $ python3 run.py 
* Serving Flask app "app" (lazy loading)
* Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
\end{lstlisting}

\section{Depuración de errores}

Como todo software, \textit{Pizarra} no estará exento de errores o \foreign{english}{bugs} que no se han identificado en la etapa de desarrollo. Para aplacar estos problemas \textit{python} ofrece la ejecución de \textit{scripts} en modo \textit{Debug}, lo que nos permite poner puntos de ruptura y hacer una ejecución ``paso a paso'' del código para identificar las causas de errores.

En el entorno de desarrollo local el modo \textit{Debug} siempre está habilitado pero sii queremos habilitarlo cuando ejecutamos el aplicativo en modo \textit{Production} debemos especificarlo explícitamente en las variables de entorno del \acrshort{so}, en este caso y para más información revisar el Apéndice A: Configuración del Sistema.

\section{Calidad de código}

Crear código de calidad es una tarea compleja y si en un futuro se espera colaboración externa en \textit{Pizarra} se debe seguir una serie de pautas para que todos puedan trabajar sin tener que descifrar lo que se ha hecho. En estos casos lo que se hace es seguir unas guías de estilo que estipulan ciertas reglas de cómo debe escribirse el código fuente y hay herramientas que ayudan a identificar problemas como \Gls{paquete} \textit{flake8}\footnote{Sitio Web de Flake8: \url{https://flake8.pycqa.org/en/latest/}}.

En el directorio raíz del repositorio de código se ejecuta el siguiente comando y podemos ver un listado de reglas que no se cumplen y debemos solucionar:.

\begin{lstlisting}[style=ascii-tree]
$ flake8 app/
app/__init__.py:8:1: F401 'logging.DEBUG' imported but unused
app/__init__.py:71:5: E722 do not use bare 'except'
app/home/routes.py:59:101: E501 line too long (106 > 100 characters)
app/home/routes.py:210:5: E722 do not use bare 'except'
app/home/routes.py:216:101: E501 line too long (108 > 100 characters)
app/admin/forms.py:32:28: N805 first argument of a method should be named 'self'
\end{lstlisting}

Adicionalmente, la configuración de \textit{flake8} se encuentra en el fichero \textbf{setup.tfg} en la raíz del repositorio en caso que se desee modificar la forma en la cual se ejecuta.

\begin{code}{setup.tfg}}
[flake8]
max-line-length=100
ignore=E402,E266
exclude=./migrations
\end{code}

\section{Gestión de versiones}

Como se ha visto anteriormente desde el inicio del desarrollo de la aplicación se ha utilizado como herramienta de gestión de versiones \textit{Git}\footnote{Sitio web Git: \url{https://git-scm.com/}.} para el seguimiento de los cambios y entregables. La rama principal es ``master'' y solo para requisitos de gran impacto se han creado nuevas que finalmente han sido fusionadas a ``master'' una vez validadas. Cada vez que se producía el fin de un \foreign{english}{sprint} con su bloque de tareas se creaba una nueva ``etiqueta'' o \foreign{english}{tag} marcando la versión; comenzando desde la \textit{0.1} llegando al final de la entrega del \acrshort{tfg} a la \textit{1.0}.

Este ha sido un trabajo de una sola persona y se ha seguido el método de \foreign{english}{Feature Branch Workflow} \cite{link-git-flow} donde se tiene una rama principal y nuevas funcionalidades o \foreign{english}{features} divergen de esta para luego volver a fusionarse. Ya que se espera recibir colaboraciones a futuro se deberá acomodar a un proceso que involucre a un equipo de trabajo y ramas en diferentes estados como \foreign{english}{dev, release} y \foreign{english}{master} como en el método \foreign{english}{Gitflow Workflow}.

\chapter{Extensibilidad}

Uno de los puntos más importantes es permitir la colaboración y que \textit{Pizarra} se pueda utilizar otros sistemas de tareas que no sean una \Gls{cola} local o la de \kahan(TORQUE\footnote{Sitio web de TORQUE: \url{https://adaptivecomputing.com/cherry-services/torque-resource-manager/}.}); ya sabiendo que en el próximo curso académico \kahan será reemplazado por \textit{kahan2} y deberá ser adecuado. Además, la colaboración y uso no debe estar limitado por el lenguaje y debe estar abierto a ser localizado en diferentes idiomas. En este capítulo trataremos estos dos apartados al ser los más importantes.

\section{Otros sistemas de Gestión de Tareas}

En el capítulo 5: Ejecución en una Cola interna ya se ha explicado el proceso de desarrollo y creación de un autómata para los pasos que seguiría en \gls{envio} de una \gls{tarea}. En modo de ejemplo se había presentado una versión simplificada del autómata para un \foreign{english}{job} local (clase \textit{LocalJob}) y para este tipo de ``trabajos'' la definición es muy simple ya que este tipo de \foreign{english}{jobs} no deben esperar su turno para ser procesados como en \kahan.

Para mostrar la facilidad con la cual se puede extender \textit{Pizarra} a otros sistemas de \gls{cola}s se hará un repaso de como se ha definido el nuevo autómata para la clase \textit{KahanJob} que extiende de \textit{LocalJob}.

Para el sistema de \Gls{cola}s de \kahan podemos ver el siguiente extracto donde se han creado nuevos métodos para obtener el ID con el que se ha desplegado la tarea y también la verificación de como si la tarea está todavía en la \gls{cola} o ejecutandose debemos esperar (\textit{StepResult.WAIT}) y volver a verificar en un futuro. \newline

\begin{code}{models\_jobs.py}
...
def deploy(self):
	remote = RemoteClient.Instance()
	output = remote.execute_commands_in_directory(self.remote_directory, ['qsub script.sh'])
	kahan_queue_id = get_kahan_queue_id(output)
	if kahan_queue_id is None:
		return StepResult.NOK
	
	self.user_request.kahan_id = kahan_queue_id
	return StepResult.OK

def check_queue(self):
	remote = RemoteClient.Instance()
		
	output = remote.execute_commands(['qstat |grep ' + self.user_request.kahan_id])
	request_status = get_kahan_queue_status(output)
	
	if request_status == RequestStatus.QUEUED or request_status == RequestStatus.RUNNING:
		if request_status != self.user_request.status:
			self.update_request(request_status)
		# requeue task
		return StepResult.WAIT
...
\end{code}

Al comenzar la ejecución de los métodos \textit{deploy} y \textit{check\_queue} se obtiene una instancia de conexión con \kahan; esto se hace utilizando un patrón de diseño llamado \foreign{english}{Singleton} \cite{book-software-design-patterns} para evitar abrir de múltiples conexiones \textit{SSH} con el servidor frontal del \foreign{english}{cluster}. El método deploy ejecuta el comando ``qsub script.sh'' para encolar el trabajo y obtiene el ID de la \gls{cola}. En cambio, \textit{check\_queue} ejecuta el comando ``qstat'' para ver el estado del trabajo en la \gls{cola} y compara el estado, si sigue estando encolado (\textit{QUEUED}) o ejecutandose (\textit{RUNNING}) habrá que volver a revisar en un futuro.

Estos nuevos estados del autómata que difieren de la clase \textit{LocalJob} se pueden ver en la definición de la clase \textit{KahanJob}: \newline

\begin{code}{models\_jobs.py}
class KahanJob(LocalJob):
	def __init__(self, user_request):
		super().__init__(user_request)
		self.task_process = {
			RequestStatus.CREATED: {
				'f': self.start,
				'steps': {
					StepResult.OK: RequestStatus.VERIFYING,
				}
			},
			RequestStatus.VERIFYING: {
				'f': self.verify,
				'steps': {
					StepResult.OK: RequestStatus.COMPILING,
					StepResult.NOK: RequestStatus.ERROR
				}
			},
			RequestStatus.COMPILING: {
				'f': self.compile,
				'steps': {
					StepResult.OK: RequestStatus.DEPLOYING,
					StepResult.NOK: RequestStatus.ERROR
				}
			},
			RequestStatus.DEPLOYING: {
				'f': self.deploy,
				'steps': {
					StepResult.OK: RequestStatus.QUEUED,
					StepResult.NOK: RequestStatus.ERROR
				}
			},
		...
\end{code}

\section{Localización}

\textit{Pizarra} utiliza el \Gls{paquete} \textit{Babel}\footnote{Paquete \textit{Babel}: \url{http://babel.pocoo.org/en/latest/}.} para ofrecer los diferentes idiomas disponibles a los usuarios. La configuración de \textit{Babel} se encuentra en el fichero \textbf{babel.cfg}\footnote{Configuración de \textit{Babel}: \url{https://github.com/nimar3/pizarra/blob/master/babel.cfg}.} en la que se define los ficheros a escanear y extraer texto para traducir.

\begin{lstlisting}[style=ascii-tree]
[python: app/**.py]
[jinja2: app/**/templates/**.html]
extensions=jinja2.ext.autoescape,jinja2.ext.with_
\end{lstlisting}

A continuación se muestra el ``paso a paso'' para añadir un nuevo lenguaje a la aplicación.

\begin{enumerate}
	\item Con el siguiente comando se extrae el texto y mientras procesan los ficheros se van mostrando mensajes en la consola . Al finalizar el resultado lo tendremos disponible en el fichero \mbox{\textbf{messages.pot}}.
	
	\begin{lstlisting}[style=ascii-tree]
	(venv) $ pybabel extract -F babel.cfg -k _l -o messages.pot .
	...
	extracting messages from app/home/templates/macros/summaries.html (extensions="jinja2.ext.autoescape,jinja2.ext.with_")
	extracting messages from app/home/templates/macros/teams.html (extensions="jinja2.ext.autoescape,jinja2.ext.with_")
	writing PO template file to messages.pot
	\end{lstlisting}
	
	\item Una vez extraído el texto hay que generar el fichero de localización para el idioma que vayamos a traducir. Las localizaciones se encuentran en el directorio \textit{/app/translations}. 
	
	\begin{lstlisting}[style=ascii-tree]
	(env) $ pybabel init -i messages.pot -d app/translations -l es
	creating catalog app/translations/es/LC_MESSAGES/messages.po based on messages.pot
	\end{lstlisting}
	
	\item El siguiente paso es comenzar a añadir las traducciones en las líneas identificadas con \textit{msgstr}.
	
	\begin{lstlisting}[style=ascii-tree]
	$  cat app/translations/es/LC_MESSAGES/messages.po
	...
	#: app/account/routes.py:34
	msgid "New Access Token has been generated!"
	msgstr "Nuevo Token de acceso ha sido generado!"
	
	#: app/account/routes.py:54
	msgid "You joined Team {}"
	msgstr "Te has unido al equipo {}"
	
	#: app/account/routes.py:56
	msgid "You are unable to join team {} because is full"
	msgstr ""
	...
	\end{lstlisting}
	
	\item Se compilan las traducciones.
	
	\begin{lstlisting}[language=bash]
	(env) $ pybabel compile -d app/translations
	compiling catalog app/translations/es/LC_MESSAGES/messages.po to app/translations/es/LC_MESSAGES/messages.mo
	\end{lstlisting}
	
	\item Y se añade a la configuración de Pizarra el nuevo idioma disponible.
	
	\begin{code}{config.py}
		...
		SUPPORTED_LANGUAGES = {'es': 'Spanish', 'en': 'English'}
		...
	\end{code}
	
\end{enumerate}

Al reiniciar la aplicación tendremos en el menú se visualizará el nuevo idioma disponible y al seleccionarlo el lenguaje de la aplicación web se mantendrá durante la sesión que tengamos activa.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.50\textwidth]{img/pizarra-new-language}
	\caption[Selector de Idiomas en Pizarra]{Selector de Idiomas en Pizarra.}
	\label{figura:pizarra-new-language}
\end{figure}

\chapter{Conclusiones y trabajos futuros}

Transitar el \acrlong{gii} aunando los conocimientos adquiridos en la rama de Ingeniería de Software, me ha permitido crear una herramienta para facilitar la enseñanza y el aprendizaje en cursos venideros. Afianzando los conocimientos adquiridos y ampliando mis habilidades como profesional.

El resultado final es una herramienta innovadora que une el concepto de computación paralela, gamificación y una solución orientada a servicios que hace uso de tecnologías originales de gran aceptación en el mercado tecnológico actual. Es así que logramos obtener una solución robusta al ser extensible, mantenible y de fácil implantación.

Como todo proyecto de desarrollo de \textit{software} han ido produciéndose contratiempos como la necesidad de un motor de reglas y el despliegue de la aplicación en la nube que pudieron ser paliados gracias a la investigación y análisis de alternativas que han dado como resultado un plan de acción para llegar a una solución efectiva.

Finalmente, los objetivos se han alcanzado al haberse entregado todos los requisitos funcionales acordados al comienzo de la etapa de desarrollo, cumpliendo en tiempo y forma con lo acordado con el Tutor esperando con ansias el uso de la herramienta en el próximo curso académico y así poder analizar los resultados en un ambiente de trabajo real.

Sobre trabajos futuros ya se ha mencionado que \textit{kahan2} reemplazará al \textit{cluster} actual del \acrshort{dsic} y tendrán que hacerse en \textit{Pizarra} unas modificaciones menores para adaptarlo al nuevo \textit{cluster}. Además, como posibles mejoras, se podrían añadir aspectos de personalización en la experiencia de usuario y seguir creando pruebas unitarias para aumentar la cobertura de código y así mejorar la calidad del código fuente.


\section{Relación del trabajo con los estudios cursados}

Durante todo el proceso de creación de \textit{Pizarra} se han utilizado conocimientos adquiridos en el \acrshort{gii} y específicamente de la rama Ingeniería de Software. En su conjunto las siguientes asignaturas han sido el punto de partida para la creación de la aplicación:

\begin{itemize}
	\item \textbf{Proyecto de Ingeniería de Software}: en esta asignatura se ha realizado la implementación de una aplicación utilizando el modelo de Desarrollo Ágil y ha servido como una experiencia previa enriquecedora.
	\item \textbf{Proceso de Software}: en esta asignatura se han visto las metodologías de Desarrollo Tradicional y Desarrollo Ágil.
	\item \textbf{Computación Paralela}: los conceptos de computación paralela fueron vistos aquí y la experiencia previa de laboratorio interactuando con el \textit{cluster} \kahan ha sido fundamental para el proyecto.
	\item \textbf{Diseño de Software}: varios de los patrones de diseño de \foreign{english}{software} presentados en la memoria que utiliza \textit{Pizarra} se han visto e implementado en las prácticas de esta asignatura. 
	\item \textbf{Mantenimiento y Evolución de Software}: conceptos como el control de versiones, mantenimiento y guías de estilo se han visto en esta asignatura y utilizados para la realizar una entrega de \foreign{english}{software} de calidad.
	\item \textbf{Análisis y Especificación de Requisitos}: el capítulo de Análisis de Requisitos recoge conceptos reforzados en esta asignatura como el prototipado, casos de uso, gestión del riesto y más.
	\item \textbf{Ingeniería del Software}: durante la asignatura se ha visto el diseño de software con el uso de diagramas y la utilización de UML.
	\item \textbf{Tecnología de Sistemas de Información en la Red}: en las prácticas de la asignatura se ha visto \textit{Docker} y el despliegue de servicios.
	\item \textbf{Teoría de Autómatas y Lenguajes Formales}: en esta asignatura se ven los conceptos de autómata finito, que han sido utilizados para las colas internas de \textit{Pizarra}.
\end{itemize}

\section{Competencias transversales}

Tras la realización del \acrshort{tfg} se han reforzado las siguientes competencias transversales:

\begin{itemize}
	\item \textbf{Comprensión e integración}: al comprender diferentes conceptos de las asignaturas de grado estableciendo relaciones entre ellas y aplicarlas en un proyecto final.
	\item \textbf{Aplicación y pensamiento práctico}: al realizar un análisis de las diferentes alternativas y soluciones posibles adaptándome al cambio constante que conlleva un Desarrollo Ágil.
	\item \textbf{Análisis y resolución de problemas}: al encontrar soluciones efectivas a los problemas que fueron manifestándose a lo largo del proyecto.
	\item \textbf{Innovación, creatividad y emprendimiento}: al crear una herramienta que une los conceptos de programación paralela, gamificación y servicios en la nube.
	\item \textbf{Diseño y proyecto}: al diseñar y concretar satisfactoriamente un proyecto de ingeniería de software.
	\item \textbf{Comunicación efectiva}: al crear esta memoria transmitiendo los conocimientos adquiridos en el \acrshort{gii}.
	\item \textbf{Pensamiento crítico}: al realizar un trabajo de investigación utilizando fuentes fiables y haciendo valoraciones sobre las decisiones y sus implicaciones.
	\item \textbf{Aprendizaje permanente}: al incorporar conocimientos en diferentes materias de forma autónoma que facilitaron la creación de una nueva herramienta adaptada a las necesidades actuales.
	\item \textbf{Planificación y gestión del tiempo}: al cumplir en tiempo y forma la fecha pautada con el Tutor para la entrega del \acrshort{tfg}.
	\item \textbf{Instrumental específica}: al incorporar nuevas herramientas y conocimientos combinándolas de forma efectiva para desarrollar este proyecto profesional.
\end{itemize}


\begin{thebibliography}{10}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MODEL D'ARTICLE                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\bibitem{light}
%   Jennifer~S. Light.
%   \newblock When computers were women.
%   \newblock \textit{Technology and Culture}, 40:3:455--483, juliol, 1999.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MODEL DE LLIBRE                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibitem{libingreq}
	del Águila Cano, Isabel María.
	\newblock ``Documentación de los requisitos''. \textit{Ingeniería de requisitos: Material didáctico. Cuaderno de teoría}.
	\newblock Almería, Editorial Universidad de Almería, 2019, pp 67-82.ISBN: 9788417261795

\bibitem{libingsoft}
	Amo, F. Alonso. Martínez Normand, Loïc A. Segovia Pérez, Francisco Javier.
	\newblock ``El ciclo de vida clásico''. \textit{Introducción a la Ingeniería del software}.
	\newblock Madrid: Delta Publicaciones, 2005, pp. 77-91. ISBN: 8496477002
	
\bibitem{book-mvc}
	Bourne, John R.
	\newblock ``Tools for Building Applications: The Model-View-Controller Paradigm and View Components''.\textit{Object-Oriented Engineering: Building Engineering Systems Usig Smalltalk-80}
	\newblock United States of America: CRC Press, 1992. pp. 175-216 .ISBN: 9780256112108
	
\bibitem{book-mastering-flask}
	Stouffer, Jack.
	\newblock ``Creating Controllers with Blueprints''. \textit{Mastering Flask}
	\newblock Birbingham: Pack Publishing Ltd., 2015, pp. 57-62. ISBN: 9781784391928
	
	
\bibitem{book-developing-web-python}
	Grinberg, Miguel
	\newblock ``Deployment''. \textit{Flask Web Development: Developing Web Applications with Python}
	\newblock California: O'Reilly Media, Inc., 2014. ISBN: 9781491947616
	
\bibitem{book-software-design-patterns}
	Gamma, E. and Helm, R. and Johnson, R. and Vlissides, J.
	\newblock \textit{Design Patterns: Elements of Reusable Object-Oriented Software}
	\newblock Pearson Education, 1994. ISBN: 9780321700698
	


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MODEL D'URL                                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibitem{link-esp-rq-jan}
   Junta de Andalucía. \textit{Plantilla Especificación de Requisitos} [en línea]
   \newblock Consultado en 10 Mayo 2020.
   \url{http://www.juntadeandalucia.es/servicios/madeja/contenido/recurso/456}.

\bibitem{link-cluster-kahan}
	Jose E. Roman. \textit{Clúster de Computación ``Kahan''} [en línea]
	\newblock Consultado en 12 Abril 2020.
	\url{http://personales.upv.es/jroman/kahan.html}
	
\bibitem{link-coursera-google}
	Google. \textit{Getting Started with Google Kubernetes Engine} [en línea]
	\newblock Consultado en 1 Junio 2020.
	\url{https://www.coursera.org/learn/google-kubernetes-engine}
	
\bibitem{link-deploy-flask}
	Pallets \textit{Standalone WSGI Containers} [en línea]
	\newblock Consultado en 20 Mayo 2020.
	\url{https://flask.palletsprojects.com/en/1.1.x/deploying/wsgi-standalone/}
	
\bibitem{link-sharing-docker-containers}
	Jacobs, Todd A. \textit{Sharing Docker Containers across DevOps Environments} [en línea]
	\newblock Consultado en 2 Mayo 2020.
	\url{https://www.linuxjournal.com/content/sharing-docker-containers-across-devops-environments}
	
\bibitem{link-tablon-faq}
	Grupo Trasgo \textit{Tablón FAQ} [en línea]
	\newblock Consultado en 5 Marzo 2020.
	\url{http://frontendv.infor.uva.es/faq}
	
\bibitem{link-rule-engine}
	McIntyre, Spencer. \textit{Rule Engine Documentation} [en línea]
	\newblock Consultado en 3 Junio 2020.
	\url{https://zerosteiner.github.io/rule-engine/}
	
\bibitem{link-git-flow}
	Attlasian. \textit{Comparing Workflows} [en línea]
	\newblock Consultado en 1 Marzo 2020.
	\url{https://www.atlassian.com/git/tutorials/comparing-workflows}


\end{thebibliography}
\cleardoublepage

\APPENDIX

\chapter{Configuración del sistema}

Para un correcto funcionamiento de \textit{Pizarra} el sistema debe inicializarse siguiendo los pasos descritos a continuación ya que aunque se dispone de un \foreign{english}{script} que realiza el despliegue de forma automatizada hay algunos pasos que requieren de intervención manual.

\section{Inicialización}

Antes de comenzar con la inicialización del sistema debemos exportar las variables de entorno del \acrshort{so} que utiliza el \foreign{english}{script}. Abrimos una consola y ejecutamos los siguientes comandos donde \textit{pizarra-id} es el ID de proyecto en \acrfull{gce}.

\begin{lstlisting}[style=ascii-tree]
$ export PROJECT_ID=pizarra-id
$ export DB_USERNAME=pizarra
$ export DB_PASSWORD=pizarra
\end{lstlisting}

Si se quisiera cambiar algún parámetro por defecto de \textit{Pizarra}, debemos modificar el fichero \textbf{pizarra.yaml}\footnote{Fichero YAML de Pizarra: \url{https://github.com/nimar3/pizarra/blob/master/gce/pizarra.yaml}.}. En el siguiente extracto se han cambiado los puntos de penalización al obtener un \textit{KO} y \textit{TIMEWALL} en el envío de una \Gls{tarea} y la carga de datos de ejemplo.

\begin{lstlisting}[style=ascii-tree]
...
spec:
  containers:
    - image: eu.gcr.io/pizarra-279100/pizarra
      name: pizarra
      env:
        - name: TIMEWALL_PENALTY
          value: "-20"
        - name: KO_PENALTY
          value: "-30"
        - name: IMPORT_SAMPLE_DATA
          value: "True"
...          
\end{lstlisting}

A continuación se ejecuta el script.

\begin{lstlisting}[style=ascii-tree]
$ sh commands.sh
\end{lstlisting}

Al terminar la ejecución deberíamos tener \textit{Pizarra} con todos los componentes desplegados. Podemos obtener el estado de los \gls{contenedor}es y servicios con los siguientes comandos.

\begin{lstlisting}[style=ascii-tree]
$ kubectl get pods
$ kubectl get services
\end{lstlisting}

\section{Parámetros}

Al iniciar un \Gls{contenedor} utilizamos variables de entorno del \acrshort{so} para configurar su funcionamiento. \textit{Pizarra} soporta estas variables para dar diferentes posibilidades en cómo queremos que se comporte el aplicativo. 

Los mencionados a continuación con su descripción y opciones son los más relevantes en un despliegue. También se listan otros parámetros adicionales como referencia. Todos estos pueden ser consultados en el fichero de configuración\footnote{Fichero de Configuración: \url{https://github.com/nimar3/pizarra/blob/master/config.py}.}.

\begin{itemize}
	\item \textbf{APP\_MODE}
	\begin{itemize}
		\item Descripción: ejecución del aplicativo como aplicación web o \textit{Worker}
		\item Opciones:
		\begin{itemize}
			\item Pizarra: aplicativo web.
			\item Worker: worker.
		\end{itemize}
		\item Valor por defecto: \textit{Pizarra}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{CONFIG\_MODE}
	\begin{itemize}
		\item Descripción: modo en el cual queremos que se ejecute \textit{Pizarra}.
		\item Opciones:
		\begin{itemize}
			\item Debug: modo Debug habilitado y \acrshort{bd} SQLite.
			\item Production: modo Debug deshabilitado y \acrshort{bd} PostgreSQL.
		\end{itemize}
		\item Valor por defecto: \textit{Debug}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{REMOTE\_HOST}
	\begin{itemize}
		\item Descripción: hostname o IP del sistema externo a conectarnos para las colas de \kahan.
		\item Valor por defecto: \textit{kahan.dsic.upv.es}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{REMOTE\_USER}
	\begin{itemize}
		\item Descripción: usuario con el que nos conectaremos por \acrshort{ssh} y \acrshort{scp} a \kahan.
		\item Valor por defecto: \textit{pizarra}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{REMOTE\_PATH}
	\begin{itemize}
		\item Descripción: directorio remoto donde se copiarán los ficheros de cada ejecución en \kahan.
		\item Valor por defecto: \textit{/pizarra}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{SSH\_FILE\_PATH}
	\begin{itemize}
		\item Descripción: ubicación de la clave privada para conectarnos por \acrshort{ssh} y \acrshort{scp} a \kahan.
		\item Valor por defecto: \textit{app/data/keys/id\_rsa}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{LOG\_LEVEL}
	\begin{itemize}
		\item Descripción: establece el nivel de mensajes que deben mostrarse al ejecutarse el aplicativo.
		\item Opciones
		\begin{itemize}
			\item CRITICAL
			\item ERROR
			\item WARNING
			\item INFO
			\item DEBUG
		\end{itemize}
		\item Valor por defecto: \textit{INFO}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{SECRET\_KEY}
	\begin{itemize}
		\item Descripción: clave secreta con la que se encriptarán las contraseñas, no se puede cambiar una vez desplegada la aplicación y por seguridad nunca debe utilizarse el valor por defecto.
		\item Valor por defecto: \textit{pizarra-app}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{IMPORT\_SAMPLE\_DATA}
	\begin{itemize}
		\item Descripción: borrado de información de la \acrshort{bd} e importación de data de ejemplo.
		\item Valor por defecto: \textit{False}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{TIME\_BETWEEN\_REQUESTS}
	\begin{itemize}
		\item Descripción: tiempo mínimo en segundos que debe esperar un \gls{alumno} entre cada envío de \Gls{tarea}s.
		\item Valor por defecto: \textit{60}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{TEAM\_MAX\_SIZE}
	\begin{itemize}
		\item Descripción: tamaño máximo de \Gls{alumno}s que puede tener un \Gls{equipo}.
		\item Valor por defecto: \textit{3}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{REGISTRATION\_ENABLED}
	\begin{itemize}
		\item Descripción: habilita el registro de usuarios en el aplicativo.
		\item Valor por defecto: \textit{False}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{TIMEWALL\_PENALTY}
	\begin{itemize}
		\item Descripción: puntos de penalización al obtener un resultado de \textit{TIMEWALL} en un envío de \Gls{tarea}.
		\item Valor por defecto: \textit{-10}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{KO\_PENALTY}
	\begin{itemize}
		\item Descripción: puntos de penalización al obtener un resultado de \textit{KO} en un envío de \Gls{tarea}.
		\item Valor por defecto: \textit{-15}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{DEBUG}
	\begin{itemize}
		\item Descripción: inicia el aplicativo en modo Debug, útil para identificar errores.
		\item Valor por defecto: \textit{False}
	\end{itemize}
\end{itemize}

\subsection*{Parámetros adicionales}

\begin{itemize}
	\item SQLALCHEM\_DATABASE\_URI
	\item SQLALCHEMY\_TRACK\_MODIFICATIONS
	\item JSONIFY\_PRETTYPRINT\_REGULAR
	\item SUPPORTED\_LANGUAGES
	\item BABEL\_DEFAULT\_LOCALE
	\item BABEL\_DEFAULT\_TIMEZONE
	\item UPLOAD\_FOLDER
	\item FILE\_ALLOWED\_EXTENSIONS
	\item MAX\_CONTENT\_LENGTH
	\item TIMEWALL
	\item FORBIDDEN\_CODE
	\item RQ\_DASHBOARD\_REDIS\_URL
	\item QUEUES
	\item COMPILER
\end{itemize}

\glsaddall
\printglossary[title=Acrónimos,type=\acronymtype]

\glsaddall
\printglossary[title=Términos,toctitle=Terms and abbreviations]

\end{document}
